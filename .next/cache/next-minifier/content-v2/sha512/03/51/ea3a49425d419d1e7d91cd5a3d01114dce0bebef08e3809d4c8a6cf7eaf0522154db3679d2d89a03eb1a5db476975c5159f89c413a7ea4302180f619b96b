{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[7],{NKCw:function(e,t,s){\"use strict\";s.d(t,\"a\",(function(){return T})),s.d(t,\"b\",(function(){return U})),s.d(t,\"c\",(function(){return g})),s.d(t,\"d\",(function(){return L})),s.d(t,\"e\",(function(){return ee})),s.d(t,\"f\",(function(){return Re}));var r=s(\"q1tI\"),a=e=>\"checkbox\"===e.type,n=e=>e instanceof Date,i=e=>null==e;const o=e=>\"object\"===typeof e;var l=e=>!i(e)&&!Array.isArray(e)&&o(e)&&!n(e),u=e=>e.substring(0,e.search(/.\\d/))||e,c=(e,t)=>[...e].some((e=>u(t)===e)),d=e=>e.filter(Boolean),f=e=>void 0===e,g=(e,t,s)=>{if(l(e)&&t){const r=d(t.split(/[,[\\].]+?/)).reduce(((e,t)=>i(e)?e:e[t]),e);return f(r)||r===e?f(e[t])?s:e[t]:r}};const y=\"blur\",m=\"change\",b=\"onBlur\",h=\"onChange\",v=\"onSubmit\",_=\"onTouched\",p=\"all\",V=\"max\",x=\"min\",O=\"maxLength\",A=\"minLength\",j=\"pattern\",w=\"required\",F=\"validate\";var S=(e,t)=>{const s=Object.assign({},e);return delete s[t],s};const k=r.createContext(null);k.displayName=\"RHFContext\";const D=()=>r.useContext(k);var C=(e,t,s,r=!0)=>{function a(a){return()=>{if(a in e)return t[a]!==p&&(t[a]=!r||p),s&&(s[a]=!0),e[a]}}const n={};for(const i in e)Object.defineProperty(n,i,{get:a(i)});return n},E=e=>l(e)&&!Object.keys(e).length,B=(e,t,s)=>{const r=S(e,\"name\");return E(r)||Object.keys(r).length>=Object.keys(t).length||Object.keys(r).find((e=>t[e]===(!s||p)))},N=e=>Array.isArray(e)?e:[e];function M(e){const t=D(),{name:s,control:n=t.control,shouldUnregister:i}=e,[o,u]=r.useState(g(n._formValues,s,g(n._defaultValues,s,e.defaultValue))),d=function(e){const t=D(),{control:s=t.control,disabled:a,name:n}=e||{},i=r.useRef(n),[o,l]=r.useState(s._formState.val),u=r.useRef({isDirty:!1,dirtyFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1});return i.current=n,r.useEffect((()=>{const e=s._subjects.state.subscribe({next:e=>(!i.current||!e.name||N(i.current).includes(e.name))&&B(e,u.current)&&l(Object.assign(Object.assign({},s._formState.val),e))});return a&&e.unsubscribe(),()=>e.unsubscribe()}),[a,s]),C(o,s._proxyFormState,u.current,!1)}({control:n||t.control,name:s}),f=n.register(s,Object.assign(Object.assign({},e.rules),{value:o})),b=r.useCallback(((e,t)=>{const s=g(n._fields,e);s&&(s._f.mount=t)}),[n]);return r.useEffect((()=>{const e=n._subjects.control.subscribe({next:e=>(!e.name||s===e.name)&&u(g(e.values,s))});return b(s,!0),()=>{e.unsubscribe();const t=n._shouldUnregister||i;(c(n._names.array,s)?t&&!n._isInAction.val:t)?n.unregister(s):b(s,!1)}}),[s,n,i,b]),{field:{onChange:e=>{const t=(e=>l(e)&&e.target?a(e.target)?e.target.checked:e.target.value:e)(e);u(t),f.onChange({target:{value:t,name:s},type:m})},onBlur:()=>{f.onBlur({target:{name:s},type:y})},name:s,value:o,ref:e=>e&&f.ref({focus:()=>e.focus&&e.focus(),setCustomValidity:t=>e.setCustomValidity(t),reportValidity:()=>e.reportValidity()})},formState:d,fieldState:{invalid:!!g(d.errors,s),isDirty:!!g(d.dirtyFields,s),isTouched:!!g(d.touchedFields,s),error:g(d.errors,s)}}}const T=e=>e.render(M(e));var U=(e,t,s,r,a)=>t?Object.assign(Object.assign({},s[e]),{types:Object.assign(Object.assign({},s[e]&&s[e].types?s[e].types:{}),{[r]:a||!0})}):{},R=e=>/^\\w*$/.test(e),I=e=>d(e.replace(/[\"|']|\\]/g,\"\").split(/\\.|\\[/));function L(e,t,s){let r=-1;const a=R(t)?[t]:I(t),n=a.length,i=n-1;for(;++r<n;){const t=a[r];let n=s;if(r!==i){const s=e[t];n=l(s)||Array.isArray(s)?s:isNaN(+a[r+1])?{}:[]}e[t]=n,e=e[t]}return e}const $=(e,t,s)=>{for(const r of s||Object.keys(e)){const s=g(e,r);if(s){const e=s._f,r=S(s,\"_f\");if(e&&t(e.name)){if(e.ref.focus&&f(e.ref.focus()))break;if(e.refs){e.refs[0].focus();break}}else l(r)&&$(r,t)}}};var q=(e,t,s)=>s&&!s.shouldFocus?s.focusName||`${e}.${s.focusIndex}.`:`${e}.${t}.`,P=(e,t,s)=>e.map(((e,r)=>{const a=t.current[r];return Object.assign(Object.assign({},e),a?{[s]:a[s]}:{})})),H=()=>{const e=\"undefined\"===typeof performance?Date.now():1e3*performance.now();return\"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g,(t=>{const s=(16*Math.random()+e)%16|0;return(\"x\"==t?s:3&s|8).toString(16)}))},W=(e=[],t)=>e.map((e=>Object.assign(Object.assign({},e[t]?{}:{[t]:H()}),e)));function J(e,t){return[...N(e),...N(t)]}var K=e=>Array.isArray(e)?e.map((()=>{})):void 0;function z(e,t,s){return[...e.slice(0,t),...N(s),...e.slice(t)]}var G=(e,t,s)=>Array.isArray(e)?(f(e[s])&&(e[s]=void 0),e.splice(s,0,e.splice(t,1)[0]),e):[];function Q(e,t){return[...N(t),...N(e)]}var X=(e,t)=>f(t)?[]:function(e,t){let s=0;const r=[...e];for(const a of t)r.splice(a-s,1),s++;return d(r).length?r:[]}(e,N(t).sort(((e,t)=>e-t))),Y=(e,t,s)=>{e[t]=[e[s],e[s]=e[t]][0]},Z=(e,t,s)=>(e[t]=s,e);const ee=e=>{const t=D(),{control:s=t.control,name:a,keyName:n=\"id\",shouldUnregister:i}=e,[o,l]=r.useState(W(s._getFieldArrayValue(a),n)),u=r.useRef(o);u.current=o,s._names.array.add(a);return r.useEffect((()=>{if(s._isInAction.val=!1,s._names.watchAll)s._subjects.state.next({});else for(const e of s._names.watch)if(a.startsWith(e)){s._subjects.state.next({});break}s._subjects.watch.next({name:a,values:s._formValues}),s._names.focus&&$(s._fields,(e=>e.startsWith(s._names.focus))),s._names.focus=\"\",s._proxyFormState.isValid&&s._updateValid()}),[o,a,s,n]),r.useEffect((()=>{const e=s._subjects.array.subscribe({next({values:e,name:t}){t!==a&&t||l(W(g(e,a),n))}});return!g(s._formValues,a)&&L(s._formValues,a,[]),()=>{e.unsubscribe(),(s._shouldUnregister||i)&&s.unregister(a)}}),[a,s,n,i]),{swap:r.useCallback(((e,t)=>{const r=P(s._getFieldArrayValue(a),u,n);Y(r,e,t),l(r),s._updateFieldArray(n,a,Y,{argA:e,argB:t},r,!1)}),[a,s,n]),move:r.useCallback(((e,t)=>{const r=P(s._getFieldArrayValue(a),u,n);G(r,e,t),l(r),s._updateFieldArray(n,a,G,{argA:e,argB:t},r,!1)}),[a,s,n]),prepend:r.useCallback(((e,t)=>{const r=Q(P(s._getFieldArrayValue(a),u,n),W(N(e),n));l(r),s._updateFieldArray(n,a,Q,{argA:K(e)},r),s._names.focus=q(a,0,t)}),[a,s,n]),append:r.useCallback(((e,t)=>{const r=N(e),i=J(P(s._getFieldArrayValue(a),u,n),W(N(e),n));l(i),s._updateFieldArray(n,a,J,{argA:K(e)},i),s._names.focus=q(a,i.length-r.length,t)}),[a,s,n]),remove:r.useCallback((e=>{const t=X(P(s._getFieldArrayValue(a),u,n),e);l(t),s._updateFieldArray(n,a,X,{argA:e},t)}),[a,s,n]),insert:r.useCallback(((e,t,r)=>{const i=z(P(s._getFieldArrayValue(a),u,n),e,W(N(t),n));l(i),s._updateFieldArray(n,a,z,{argA:e,argB:K(t)},i),s._names.focus=q(a,e,r)}),[a,s,n]),update:r.useCallback(((e,t)=>{const r=P(s._getFieldArrayValue(a),u,n),i=Z(r,e,t);u.current=W(i,n),l(u.current),s._updateFieldArray(n,a,Z,{argA:e,argB:t},r,!0,!1)}),[a,s,n]),fields:o}};function te(e){let t;const s=Array.isArray(e);if(e instanceof Date)t=new Date(e.getTime());else{if(!s&&!l(e))return e;t=s?[]:{};for(const s in e)t[s]=te(e[s])}return t}var se=e=>i(e)||!o(e);function re(e,t){if(se(e)||se(t)||n(e)||n(t))return e===t;const s=Object.keys(e),r=Object.keys(t);if(s.length!==r.length)return!1;for(const a of s){const s=e[a];if(!r.includes(a))return!1;if(\"ref\"!==a){const e=t[a];if((l(s)||Array.isArray(s))&&(l(e)||Array.isArray(e))?!re(s,e):s!==e)return!1}}return!0}var ae=e=>({isOnSubmit:!e||e===v,isOnBlur:e===b,isOnChange:e===h,isOnAll:e===p,isOnTouch:e===_}),ne=e=>\"file\"===e.type,ie=e=>\"function\"===typeof e,oe=e=>e instanceof HTMLElement,le=e=>\"select-multiple\"===e.type,ue=e=>\"radio\"===e.type,ce=e=>\"string\"===typeof e,de=\"undefined\"!==typeof window&&\"undefined\"!==typeof window.HTMLElement&&\"undefined\"!==typeof document,fe=e=>!oe(e)||!document.contains(e),ge=(e,t)=>e.map(((e={})=>S(e,t)));class ye{constructor(){this.tearDowns=[]}add(e){this.tearDowns.push(e)}unsubscribe(){for(const e of this.tearDowns)e();this.tearDowns=[]}}class me{constructor(e,t){this.observer=e,this.closed=!1,t.add((()=>this.closed=!0))}next(e){this.closed||this.observer.next(e)}}class be{constructor(){this.observers=[]}next(e){for(const t of this.observers)t.next(e)}subscribe(e){const t=new ye,s=new me(e,t);return this.observers.push(s),t}unsubscribe(){this.observers=[]}}var he=e=>\"boolean\"===typeof e;function ve(e,t){const s=R(t)?[t]:I(t),r=1==s.length?e:function(e,t){const s=t.slice(0,-1).length;let r=0;for(;r<s;)e=f(e)?r++:e[t[r++]];return e}(e,s),a=s[s.length-1];let n;r&&delete r[a];for(let i=0;i<s.slice(0,-1).length;i++){let t,r=-1;const a=s.slice(0,-(i+1)),o=a.length-1;for(i>0&&(n=e);++r<a.length;){const s=a[r];t=t?t[s]:e[s],o===r&&(l(t)&&E(t)||Array.isArray(t)&&!t.filter((e=>l(e)&&!E(e)||he(e))).length)&&(n?delete n[s]:delete e[s]),n=t}}return e}const _e={value:!1,isValid:!1},pe={value:!0,isValid:!0};var Ve=e=>{if(Array.isArray(e)){if(e.length>1){const t=e.filter((e=>e&&e.checked&&!e.disabled)).map((e=>e.value));return{value:t,isValid:!!t.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!f(e[0].attributes.value)?f(e[0].value)||\"\"===e[0].value?pe:{value:e[0].value,isValid:!0}:pe:_e}return _e},xe=(e,{valueAsNumber:t,valueAsDate:s,setValueAs:r})=>f(e)?e:t?\"\"===e?NaN:+e:s?new Date(e):r?r(e):e;const Oe={isValid:!1,value:null};var Ae=e=>Array.isArray(e)?e.reduce(((e,t)=>t&&t.checked&&!t.disabled?{isValid:!0,value:t.value}:e),Oe):Oe;function je(e){if(e&&e._f){const s=e._f.ref;if(e._f.refs?e._f.refs.every((e=>e.disabled)):s.disabled)return;return ne(s)?s.files:ue(s)?Ae(e._f.refs).value:le(s)?(t=s.options,[...t].filter((({selected:e})=>e)).map((({value:e})=>e))):a(s)?Ve(e._f.refs).value:xe(f(s.value)?e._f.ref.value:s.value,e._f)}var t}function we(e,t){if(se(e)||se(t))return t;for(const r in t){const a=e[r],n=t[r];try{e[r]=l(a)&&l(n)||Array.isArray(a)&&Array.isArray(n)?we(a,n):n}catch(s){}}return e}function Fe(e,t,s,r,a){let n=-1;for(;++n<e.length;){for(const r in e[n])Array.isArray(e[n][r])?(!s[n]&&(s[n]={}),s[n][r]=[],Fe(e[n][r],g(t[n]||{},r,[]),s[n][r],s[n],r)):!i(t)&&re(g(t[n]||{},r),e[n][r])?L(s[n]||{},r):s[n]=Object.assign(Object.assign({},s[n]),{[r]:!0});r&&!s.length&&delete r[a]}return s}var Se=(e,t,s)=>we(Fe(e,t,s.slice(0,e.length)),Fe(t,e,s.slice(0,e.length))),ke=(e,t)=>!d(g(e,t,[])).length&&ve(e,t),De=e=>ce(e)||r.isValidElement(e),Ce=e=>e instanceof RegExp;function Ee(e,t,s=\"validate\"){if(De(e)||Array.isArray(e)&&e.every(De)||he(e)&&!e)return{type:s,message:De(e)?e:\"\",ref:t}}var Be=e=>l(e)&&!Ce(e)?e:{value:e,message:\"\"},Ne=async(e,t,s,r)=>{const{ref:n,refs:o,required:u,maxLength:c,minLength:d,min:f,max:g,pattern:y,validate:m,name:b,valueAsNumber:h,mount:v,disabled:_}=e._f;if(!v||_)return{};const p=o?o[0]:n,S=e=>{r&&p.reportValidity&&(p.setCustomValidity(he(e)?\"\":e||\" \"),p.reportValidity())},k={},D=ue(n),C=a(n),B=D||C,N=(h||ne(n))&&!n.value||\"\"===t||Array.isArray(t)&&!t.length,M=U.bind(null,b,s,k),T=(e,t,s,r=O,a=A)=>{const i=e?t:s;k[b]=Object.assign({type:e?r:a,message:i,ref:n},M(e?r:a,i))};if(u&&(!B&&(N||i(t))||he(t)&&!t||C&&!Ve(o).isValid||D&&!Ae(o).isValid)){const{value:e,message:t}=De(u)?{value:!!u,message:u}:Be(u);if(e&&(k[b]=Object.assign({type:w,message:t,ref:p},M(w,t)),!s))return S(t),k}if(!N&&(!i(f)||!i(g))){let e,r;const a=Be(g),o=Be(f);if(isNaN(t)){const s=n.valueAsDate||new Date(t);ce(a.value)&&(e=s>new Date(a.value)),ce(o.value)&&(r=s<new Date(o.value))}else{const s=n.valueAsNumber||parseFloat(t);i(a.value)||(e=s>a.value),i(o.value)||(r=s<o.value)}if((e||r)&&(T(!!e,a.message,o.message,V,x),!s))return S(k[b].message),k}if((c||d)&&!N&&ce(t)){const e=Be(c),r=Be(d),a=!i(e.value)&&t.length>e.value,n=!i(r.value)&&t.length<r.value;if((a||n)&&(T(a,e.message,r.message),!s))return S(k[b].message),k}if(y&&!N&&ce(t)){const{value:e,message:r}=Be(y);if(Ce(e)&&!t.match(e)&&(k[b]=Object.assign({type:j,message:r,ref:n},M(j,r)),!s))return S(r),k}if(m)if(ie(m)){const e=Ee(await m(t),p);if(e&&(k[b]=Object.assign(Object.assign({},e),M(F,e.message)),!s))return S(e.message),k}else if(l(m)){let e={};for(const r in m){if(!E(e)&&!s)break;const a=Ee(await m[r](t),p,r);a&&(e=Object.assign(Object.assign({},a),M(r,a.message)),S(a.message),s&&(k[b]=e))}if(!E(e)&&(k[b]=Object.assign({ref:p},e),!s))return k}return S(!0),k};const Me={mode:v,reValidateMode:h,shouldFocusError:!0},Te=\"undefined\"===typeof window;function Ue(e={}){let t,s=Object.assign(Object.assign({},Me),e),r={isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}},o={},m={},b=s.defaultValues||{},h=!1,v=!1,_=0,V={mount:new Set,unMount:new Set,array:new Set,watch:new Set},x={};const O={isDirty:!1,dirtyFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1},A={watch:new be,control:new be,array:new be,state:new be},j=ae(s.mode),w=s.criteriaMode===p,F=e=>V.watchAll||V.watch.has(e)||V.watch.has((e.match(/\\w+/)||[])[0]),k=(e,t)=>{L(r.errors,e,t),A.state.next({errors:r.errors})},D=async(a,n,i,l,u,c)=>{const d=g(r.errors,n),f=!(!O.isValid||!(s.resolver?u:(async()=>{const e=await T(o,!0);e!==r.isValid&&(r.isValid=e,A.state.next({isValid:e}))})()));var y,m;if(e.delayError&&i?(t=t||(y=k,m=e.delayError,(...e)=>{clearTimeout(_),_=window.setTimeout((()=>y(...e)),m)}),t(n,i)):(clearTimeout(_),i?L(r.errors,n,i):ve(r.errors,n)),(c||(i?!re(d,i):d)||!E(l)||r.isValid!==f)&&!a){const e=Object.assign(Object.assign(Object.assign({},l),O.isValid&&s.resolver?{isValid:f}:{}),{errors:r.errors,name:n});r=Object.assign(Object.assign({},r),e),A.state.next(c?{name:n}:e)}x[n]--,x[n]||(A.state.next({isValidating:!1}),x={})},C=(e,t,s={},r)=>{const n=g(o,e);if(n){const o=n._f;if(o){L(m,e,xe(t,o));const n=de&&oe(o.ref)&&i(t)?\"\":t;ne(o.ref)&&!ce(n)?o.ref.files=n:le(o.ref)?[...o.ref.options].forEach((e=>e.selected=n.includes(e.value))):o.refs?a(o.ref)?o.refs.length>1?o.refs.forEach((e=>e.checked=Array.isArray(n)?!!n.find((t=>t===e.value)):n===e.value)):o.refs[0].checked=!!n:o.refs.forEach((e=>e.checked=e.value===n)):o.ref.value=n,r&&A.control.next({values:K(),name:e}),(s.shouldDirty||s.shouldTouch)&&B(e,n,s.shouldTouch),s.shouldValidate&&J(e)}}},B=(e,t,s,a=!0)=>{const n={name:e};let i=!1;if(O.isDirty){const e=r.isDirty;r.isDirty=I(),n.isDirty=r.isDirty,i=e!==n.isDirty}if(O.dirtyFields&&!s){const s=g(r.dirtyFields,e);!re(g(b,e),t)?L(r.dirtyFields,e,!0):ve(r.dirtyFields,e),n.dirtyFields=r.dirtyFields,i=i||s!==g(r.dirtyFields,e)}const o=g(r.touchedFields,e);return s&&!o&&(L(r.touchedFields,e,s),n.touchedFields=r.touchedFields,i=i||O.touchedFields&&o!==s),i&&a&&A.state.next(n),i?n:{}},M=async e=>s.resolver?await s.resolver(Object.assign({},m),s.context,((e,t,s,r)=>{const a={};for(const n of e){const e=g(t,n);e&&L(a,n,e._f)}return{criteriaMode:s,names:[...e],fields:a,shouldUseNativeValidation:r}})(e||V.mount,o,s.criteriaMode,s.shouldUseNativeValidation)):{},T=async(e,t,a={valid:!0})=>{for(const n in e){const i=e[n];if(i){const e=i._f,n=S(i,\"_f\");if(e){const n=await Ne(i,g(m,e.name),w,s.shouldUseNativeValidation);if(t){if(n[e.name]){a.valid=!1;break}}else n[e.name]&&(a.valid=!1),n[e.name]?L(r.errors,e.name,n[e.name]):ve(r.errors,e.name)}n&&await T(n,t,a)}}return a.valid},U=async({type:e,target:t,target:{value:n,name:i,type:l}})=>{let c,d;const b=g(o,i);if(b){let o=l?je(b):void 0;o=f(o)?n:o;const v=e===y,{isOnBlur:_,isOnChange:p}=ae(s.reValidateMode),V=(h=b._f,!(b._f.mount&&h&&(h.required||h.min||h.max||h.maxLength||h.minLength||h.pattern||h.validate))&&!s.resolver&&!g(r.errors,i)||(({isOnBlur:e,isOnChange:t,isOnTouch:s,isTouched:r,isReValidateOnBlur:a,isReValidateOnChange:n,isBlurEvent:i,isSubmitted:o,isOnAll:l})=>!l&&(!o&&s?!(r||i):(o?a:e)?!i:!(o?n:t)||i))(Object.assign({isBlurEvent:v,isTouched:!!g(r.touchedFields,i),isSubmitted:r.isSubmitted,isReValidateOnBlur:_,isReValidateOnChange:p},j))),O=!v&&F(i);f(o)||L(m,i,o);const S=B(i,o,v,!1),k=!E(S)||O;if(V)return!v&&A.watch.next({name:i,type:e}),k&&A.state.next(O?{name:i}:Object.assign(Object.assign({},S),{name:i}));if(x[i]=(x[i],1),A.state.next({isValidating:!0}),s.resolver){const{errors:e}=await M([i]);if(c=g(e,i),a(t)&&!c){const t=u(i),s=g(e,t,{});s.type&&s.message&&(c=s),(s||g(r.errors,t))&&(i=t)}d=E(e)}else c=(await Ne(b,g(m,i),w,s.shouldUseNativeValidation))[i];!v&&A.watch.next({name:i,type:e,values:K()}),D(!1,i,c,S,d,O)}var h},R=(e,t,s)=>{const r=g(o,e);if(r){const a=g(m,e),n=f(a)?g(b,e):a;f(n)||t&&t.defaultChecked||s?L(m,e,s?n:je(r)):C(e,n)}v&&O.isValid&&q()},I=(e,t)=>(e&&t&&L(m,e,t),!re(Object.assign({},K()),b)),q=async()=>{const e=s.resolver?E((await M()).errors):await T(o,!0);e!==r.isValid&&(r.isValid=e,A.state.next({isValid:e}))},P=(e,t,s)=>Object.entries(t).forEach((([t,r])=>{const a=`${e}.${t}`,i=g(o,a);!V.array.has(e)&&se(r)&&(!i||i._f)||n(r)?C(a,r,s,!0):P(a,r,s)})),H=(e,t,s)=>{const r=Object.assign({},v?m:f(t)?b:ce(e)?{[e]:t}:t);if(!e)return s&&(V.watchAll=!0),r;const a=[];for(const n of N(e))s&&V.watch.add(n),a.push(g(r,n));return Array.isArray(e)?a:l(a[0])?Object.assign({},a[0]):Array.isArray(a[0])?[...a[0]]:a[0]},W=(e,t=\"\")=>{for(const s in e){const r=e[s],a=t+(t?\".\":\"\")+s,n=g(o,a);n&&n._f||(l(r)||Array.isArray(r)?W(r,a):n||L(m,a,r))}},J=async(e,t={})=>{const a=N(e);let n;if(A.state.next({isValidating:!0}),s.resolver){const t=await(async e=>{const{errors:t}=await M();if(e)for(const s of e){const e=g(t,s);e?L(r.errors,s,e):ve(r.errors,s)}else r.errors=t;return t})(f(e)?e:a);n=e?a.every((e=>!g(t,e))):E(t)}else e?n=(await Promise.all(a.map((async e=>{const t=g(o,e);return await T(t._f?{[e]:t}:t)})))).every(Boolean):(await T(o),n=E(r.errors));return A.state.next(Object.assign(Object.assign({},ce(e)?{name:e}:{}),{errors:r.errors,isValidating:!1})),t.shouldFocus&&!n&&$(o,(e=>g(r.errors,e)),e?a:V.mount),O.isValid&&q(),n},K=e=>{const t=Object.assign(Object.assign({},b),m);return f(e)?t:ce(e)?g(t,e):e.map((e=>g(t,e)))},z=(e,t={})=>{for(const a of e?N(e):V.mount)V.mount.delete(a),V.array.delete(a),g(o,a)&&(t.keepValue||(ve(o,a),ve(m,a)),!t.keepError&&ve(r.errors,a),!t.keepDirty&&ve(r.dirtyFields,a),!t.keepTouched&&ve(r.touchedFields,a),!s.shouldUnregister&&!t.keepDefaultValue&&ve(b,a));A.watch.next({}),A.state.next(Object.assign(Object.assign({},r),t.keepDirty?{isDirty:I()}:{})),!t.keepIsValid&&q()},G=(e,t,s)=>{Q(e,s);let r=g(o,e);const n=f(t.value)&&t.querySelectorAll&&t.querySelectorAll(\"input,select,textarea\")[0]||t,i=(e=>ue(e)||a(e))(n);n===r._f.ref||i&&d(r._f.refs||[]).find((e=>e===n))||(r={_f:i?Object.assign(Object.assign({},r._f),{refs:[...d(r._f.refs||[]).filter((e=>oe(e)&&document.contains(e))),n],ref:{type:n.type,name:e}}):Object.assign(Object.assign({},r._f),{ref:n})},L(o,e,r),R(e,n))},Q=(e,t={})=>{const r=g(o,e);return L(o,e,{_f:Object.assign(Object.assign(Object.assign({},r&&r._f?r._f:{ref:{name:e}}),{name:e,mount:!0}),t)}),t.value&&L(m,e,t.value),!f(t.disabled)&&r&&r._f&&r._f.ref.disabled!==t.disabled&&L(m,e,t.disabled?void 0:r._f.ref.value),V.mount.add(e),!r&&R(e,void 0,!0),Te?{name:e}:Object.assign(Object.assign({name:e},f(t.disabled)?{}:{disabled:t.disabled}),{onChange:U,onBlur:U,ref:r=>{if(r)G(e,r,t);else{const r=g(o,e,{}),a=s.shouldUnregister||t.shouldUnregister;r._f&&(r._f.mount=!1),a&&(!c(V.array,e)||!h)&&V.unMount.add(e)}}})};return{control:{register:Q,unregister:z,_getWatch:H,_getIsDirty:I,_updateValid:q,_updateValues:W,_removeFields:()=>{for(const e of V.unMount){const t=g(o,e);t&&(t._f.refs?t._f.refs.every(fe):fe(t._f.ref))&&z(e)}V.unMount=new Set},_updateFieldArray:(e,t,s,a,n=[],i=!0,l=!0)=>{let u;const c=ge(n,e);if(h=!0,l&&g(o,t)&&(u=s(g(o,t),a.argA,a.argB),i&&L(o,t,u)),u=s(g(m,t),a.argA,a.argB),i&&L(m,t,u),Array.isArray(g(r.errors,t))){const e=s(g(r.errors,t),a.argA,a.argB);i&&L(r.errors,t,e),ke(r.errors,t)}if(O.touchedFields&&g(r.touchedFields,t)){const e=s(g(r.touchedFields,t),a.argA,a.argB);i&&L(r.touchedFields,t,e),ke(r.touchedFields,t)}(O.dirtyFields||O.isDirty)&&(L(r.dirtyFields,t,Se(ge(c,e),g(b,t,[]),g(r.dirtyFields,t,[]))),c&&L(r.dirtyFields,t,Se(ge(c,e),g(b,t,[]),g(r.dirtyFields,t,[]))),ke(r.dirtyFields,t)),A.state.next({isDirty:I(t,ge(c,e)),dirtyFields:r.dirtyFields,errors:r.errors,isValid:r.isValid})},_getFieldArrayValue:e=>g(v?m:b,e,[]),_subjects:A,_shouldUnregister:s.shouldUnregister,_fields:o,_proxyFormState:O,get _formValues(){return m},set _formValues(e){m=e},get _isMounted(){return v},set _isMounted(e){v=e},get _defaultValues(){return b},set _defaultValues(e){b=e},get _names(){return V},set _names(e){V=e},_isInAction:{get val(){return h},set val(e){h=e}},_formState:{get val(){return r},set val(e){r=e}},_updateProps:e=>{s=Object.assign(Object.assign({},Me),e)}},trigger:J,register:Q,handleSubmit:(e,t)=>async a=>{a&&(a.preventDefault&&a.preventDefault(),a.persist&&a.persist());let n=!0,i=Object.assign({},m);A.state.next({isSubmitting:!0});try{if(s.resolver){const{errors:e,values:t}=await M();r.errors=e,i=t}else await T(o);E(r.errors)&&Object.keys(r.errors).every((e=>g(i,e)))?(A.state.next({errors:{},isSubmitting:!0}),await e(i,a)):(t&&await t(r.errors,a),s.shouldFocusError&&$(o,(e=>g(r.errors,e)),V.mount))}catch(l){throw n=!1,l}finally{r.isSubmitted=!0,A.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:E(r.errors)&&n,submitCount:r.submitCount+1,errors:r.errors})}},watch:(e,t)=>ie(e)?A.watch.subscribe({next:s=>e(H(void 0,t),s)}):H(e,t,!0),setValue:(e,t,s={})=>{const a=g(o,e),n=V.array.has(e);L(m,e,t),n?(A.array.next({name:e,values:m}),(O.isDirty||O.dirtyFields)&&s.shouldDirty&&(L(r.dirtyFields,e,Se(t,g(b,e,[]),g(r.dirtyFields,e,[]))),A.state.next({name:e,dirtyFields:r.dirtyFields,isDirty:I(e,t)}))):!a||a._f||i(t)?C(e,t,s,!0):P(e,t,s),F(e)&&A.state.next({}),A.watch.next({name:e})},getValues:K,reset:(e,t={})=>{const s=e||b,a=te(s);if(m=a,de&&!t.keepValues)for(const r of V.mount){const e=g(o,r);if(e&&e._f){const t=Array.isArray(e._f.refs)?e._f.refs[0]:e._f.ref;try{oe(t)&&t.closest(\"form\").reset();break}catch(n){}}}t.keepDefaultValues||(b=Object.assign({},s)),t.keepValues||(o={},A.control.next({values:t.keepDefaultValues?b:Object.assign({},s)}),A.watch.next({}),A.array.next({values:a})),V={mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1,focus:\"\"},A.state.next({submitCount:t.keepSubmitCount?r.submitCount:0,isDirty:t.keepDirty?r.isDirty:!!t.keepDefaultValues&&re(e,b),isSubmitted:!!t.keepIsSubmitted&&r.isSubmitted,dirtyFields:t.keepDirty?r.dirtyFields:{},touchedFields:t.keepTouched?r.touchedFields:{},errors:t.keepErrors?r.errors:{},isSubmitting:!1,isSubmitSuccessful:!1}),v=!!t.keepIsValid},clearErrors:e=>{e?N(e).forEach((e=>ve(r.errors,e))):r.errors={},A.state.next({errors:r.errors})},unregister:z,setError:(e,t,s)=>{const a=(g(o,e,{_f:{}})._f||{}).ref;L(r.errors,e,Object.assign(Object.assign({},t),{ref:a})),A.state.next({name:e,errors:r.errors,isValid:!1}),s&&s.shouldFocus&&a&&a.focus&&a.focus()},setFocus:e=>g(o,e)._f.ref.focus()}}function Re(e={}){const t=r.useRef(),[s,a]=r.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}});t.current?t.current.control._updateProps(e):t.current=Object.assign(Object.assign({},Ue(e)),{formState:s});const n=t.current.control;return r.useEffect((()=>{const e=n._subjects.state.subscribe({next(e){B(e,n._proxyFormState,!0)&&(n._formState.val=Object.assign(Object.assign({},n._formState.val),e),a(Object.assign({},n._formState.val)))}});return()=>{e.unsubscribe()}}),[n]),r.useEffect((()=>{n._isMounted||(n._isMounted=!0,n._proxyFormState.isValid&&n._updateValid(),!e.shouldUnregister&&n._updateValues(n._defaultValues)),n._removeFields()})),t.current.formState=C(s,n._proxyFormState),t.current}},cpVT:function(e,t,s){\"use strict\";function r(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}s.d(t,\"a\",(function(){return r}))}}]);","map":{"version":3,"sources":["static/chunks/e80ab424dbecc405e68f137226e5462669a09f3a.2f5ba2767ff0646cddf5.js"],"names":["window","push","NKCw","module","__webpack_exports__","__webpack_require__","d","Controller","appendErrors","get","set","useFieldArray","useForm","react__WEBPACK_IMPORTED_MODULE_0__","isCheckBoxInput","element","type","isDateObject","data","Date","isNullOrUndefined","value","isObjectType","isObject","Array","isArray","getNodeParentName","name","substring","search","isNameInFieldArray","names","some","current","compact","filter","Boolean","isUndefined","val","undefined","obj","path","defaultValue","result","split","reduce","key","EVENTS","VALIDATION_MODE","INPUT_VALIDATION_RULES","omit","source","copy","Object","assign","FormContext","displayName","useFormContext","getProxyFormState","formState","_proxyFormState","localProxyFormState","isRoot","createGetter","prop","defineProperty","isEmptyObject","keys","length","shouldRenderFormState","formStateData","find","convertToArrayPayload","useController","props","methods","control","shouldUnregister","setInputStateValue","_formValues","_defaultValues","disabled","nameRef","updateFormState","_formState","_localProxyFormState","isDirty","dirtyFields","touchedFields","isValidating","isValid","errors","formStateSubscription","_subjects","state","subscribe","next","includes","unsubscribe","useFormState","registerProps","register","rules","updateMounted","field","_fields","_f","mount","controllerSubscription","values","_shouldUnregisterField","_shouldUnregister","_names","array","_isInAction","unregister","onChange","event","target","checked","getControllerValue","onBlur","ref","elm","focus","setCustomValidity","message","reportValidity","fieldState","invalid","isTouched","error","render","validateAllFieldCriteria","types","[object Object]","isKey","test","stringToPath","input","replace","object","index","tempPath","lastIndex","newValue","objValue","isNaN","focusFieldBy","fields","callback","fieldsNames","refs","getFocusFieldName","options","shouldFocus","focusName","focusIndex","mapCurrentIds","_fieldIds","keyName","map","output","generateId","performance","now","c","r","Math","random","toString","mapIds","append","fillEmptyArray","insert","slice","moveArrayAt","from","to","splice","prepend","removeArrayAt","indexes","i","temp","removeAtIndexes","sort","a","b","swapArrayAt","indexA","indexB","updateAt","fieldValues","setFields","_getFieldArrayValue","add","watchAll","watchField","watch","startsWith","_updateValid","fieldArraySubscription","fieldArrayName","swap","updatedFieldArrayValuesWithKey","_updateFieldArray","argA","argB","move","appendValue","remove","update","updatedFieldArrayValues","cloneObject","getTime","isPrimitive","deepEqual","object1","object2","keys1","keys2","val1","val2","getValidationModes","mode","isOnSubmit","isOnBlur","isOnChange","isOnAll","isOnTouch","isFileInput","isFunction","isHTMLElement","HTMLElement","isMultipleSelect","isRadioInput","isString","isWeb","document","live","contains","omitKey","Subscription","this","tearDowns","tearDown","teardown","Subscriber","observer","subscription","closed","Subject","observers","subscriber","isBoolean","unset","updatePath","childObject","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","defaultResult","validResult","getCheckboxValue","option","attributes","getFieldValueAs","valueAsNumber","valueAsDate","setValueAs","NaN","defaultReturn","getRadioValue","previous","getFieldValue","every","files","selected","deepMerge","targetValue","sourceValue","_a","setDirtyFields","defaultValues","parentNode","parentName","setFieldArrayDirtyFields","unsetEmptyArray","isMessage","isRegex","RegExp","getValidateError","getValueAndMessage","validationData","validateField","async","inputValue","shouldUseNativeValidation","required","maxLength","minLength","min","max","pattern","validate","inputRef","setCustomValidty","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","match","validateError","validationResult","defaultOptions","reValidateMode","shouldFocusError","isWindowUndefined","createFormControl","_delayCallback","formOptions","isSubmitted","submitCount","isSubmitting","isSubmitSuccessful","_isMounted","_timer","Set","unMount","_validateCount","validationMode","isValidateAllFieldCriteria","criteriaMode","isFieldWatched","has","updateErrorState","shouldRenderBaseOnError","shouldSkipRender","isValidFromResolver","isWatched","previousError","resolver","validateForm","shouldRenderBaseOnValid","wait","delayError","args","clearTimeout","setTimeout","updatedFormState","setFieldValue","shouldRender","fieldValue","forEach","selectRef","checkboxRef","radioRef","getValues","shouldDirty","shouldTouch","updateTouchAndDirtyState","shouldValidate","trigger","isCurrentTouched","isChanged","previousIsDirty","_getIsDirty","isPreviousFieldDirty","isPreviousFieldTouched","executeResolver","context","_fieldss","getResolverOptions","shouldCheckValid","valid","fieldError","handleChange","inputType","isBlurEvent","isReValidateOnBlur","isReValidateOnChange","shouldSkipValidation","skipValidation","parentNodeName","valError","_updateValidAndInputValue","shouldSkipValueAs","defaultChecked","setValues","entries","fieldKey","fieldName","_getWatch","fieldNames","isGlobal","_updateValues","schemaResult","executeResolverValidation","Promise","all","inputName","delete","keepValue","keepError","keepDirty","keepTouched","keepDefaultValue","keepIsValid","registerFieldRef","fieldRef","querySelectorAll","isRadioOrCheckboxFunction","_removeFields","method","shouldSet","shouldSetFields","_updateProps","handleSubmit","onValid","onInvalid","e","preventDefault","persist","hasNoPromiseError","err","info","setValue","isFieldArray","reset","formValues","keepStateOptions","updatedValues","keepValues","closest","keepDefaultValues","keepSubmitCount","keepIsSubmitted","keepErrors","clearErrors","setError","setFocus","_formControl","cpVT","_defineProperty","enumerable","configurable","writable"],"mappings":"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"},"name":"static/chunks/e80ab424dbecc405e68f137226e5462669a09f3a.2f5ba2767ff0646cddf5.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[7],{\n\n/***/ \"NKCw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Controller; });\n/* unused harmony export FormProvider */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return appendErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return set; });\n/* unused harmony export useController */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return useFieldArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"f\", function() { return useForm; });\n/* unused harmony export useFormContext */\n/* unused harmony export useFormState */\n/* unused harmony export useWatch */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isDateObject = (data) => data instanceof Date;\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !isDateObject(value);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"](null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"](FormContext);\r\nconst FormProvider = (props) => (react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (formState, _proxyFormState, localProxyFormState, isRoot = true) => {\r\n    function createGetter(prop) {\r\n        return () => {\r\n            if (prop in formState) {\r\n                if (_proxyFormState[prop] !== VALIDATION_MODE.all) {\r\n                    _proxyFormState[prop] = !isRoot || VALIDATION_MODE.all;\r\n                }\r\n                localProxyFormState && (localProxyFormState[prop] = true);\r\n                return formState[prop];\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n    const result = {};\r\n    for (const key in formState) {\r\n        Object.defineProperty(result, key, {\r\n            get: createGetter(key),\r\n        });\r\n    }\r\n    return result;\r\n};\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, _proxyFormState, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||\r\n        Object.keys(formState).find((key) => _proxyFormState[key] ===\r\n            (!isRoot || VALIDATION_MODE.all)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, disabled, name } = props || {};\r\n    const nameRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](name);\r\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](control._formState.val);\r\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    nameRef.current = name;\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, _localProxyFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, control._formState.val), formState)),\r\n        });\r\n        disabled && formStateSubscription.unsubscribe();\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, [disabled, control]);\r\n    return getProxyFormState(formState, control._proxyFormState, _localProxyFormState.current, false);\r\n}\n\nfunction useController(props) {\r\n    const methods = useFormContext();\r\n    const { name, control = methods.control, shouldUnregister } = props;\r\n    const [value, setInputStateValue] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)));\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    const registerProps = control.register(name, Object.assign(Object.assign({}, props.rules), { value }));\r\n    const updateMounted = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, value) => {\r\n        const field = get(control._fields, name);\r\n        if (field) {\r\n            field._f.mount = value;\r\n        }\r\n    }, [control]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const controllerSubscription = control._subjects.control.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        updateMounted(name, true);\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const _shouldUnregisterField = control._shouldUnregister || shouldUnregister;\r\n            if (isNameInFieldArray(control._names.array, name)\r\n                ? _shouldUnregisterField && !control._isInAction.val\r\n                : _shouldUnregisterField) {\r\n                control.unregister(name);\r\n            }\r\n            else {\r\n                updateMounted(name, false);\r\n            }\r\n        };\r\n    }, [name, control, shouldUnregister, updateMounted]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                registerProps.onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                registerProps.onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm &&\r\n                registerProps.ref({\r\n                    focus: () => elm.focus && elm.focus(),\r\n                    setCustomValidity: (message) => elm.setCustomValidity(message),\r\n                    reportValidity: () => elm.reportValidity(),\r\n                }),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nvar getFocusFieldName = (name, index, options) => options && !options.shouldFocus\r\n    ? options.focusName || `${name}.${options.focusIndex}.`\r\n    : `${name}.${index}.`;\n\nvar mapCurrentIds = (values, _fieldIds, keyName) => values.map((value, index) => {\r\n    const output = _fieldIds.current[index];\r\n    return Object.assign(Object.assign({}, value), (output ? { [keyName]: output[keyName] } : {}));\r\n});\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign(Object.assign({}, (value[keyName] ? {} : { [keyName]: generateId() })), value)));\n\nfunction append(data, value) {\r\n    return [...convertToArrayPayload(data), ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...convertToArrayPayload(data)];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar updateAt = (fieldValues, index, value) => {\r\n    fieldValues[index] = value;\r\n    return fieldValues;\r\n};\n\nconst useFieldArray = (props) => {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, keyName = 'id', shouldUnregister, } = props;\r\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](mapIds(control._getFieldArrayValue(name), keyName));\r\n    const _fieldIds = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](fields);\r\n    _fieldIds.current = fields;\r\n    control._names.array.add(name);\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValuesWithKey = append(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValuesWithKey.length - appendValue.length, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const updatedFieldArrayValuesWithKey = prepend(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, 0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValuesWithKey = removeArrayAt(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValuesWithKey);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const updatedFieldArrayValuesWithKey = insert(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index, mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        swapArrayAt(updatedFieldArrayValuesWithKey, indexA, indexB);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        moveArrayAt(updatedFieldArrayValuesWithKey, from, to);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const update = (index, value) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        const updatedFieldArrayValues = updateAt(updatedFieldArrayValuesWithKey, index, value);\r\n        _fieldIds.current = mapIds(updatedFieldArrayValues, keyName);\r\n        setFields(_fieldIds.current);\r\n        control._updateFieldArray(keyName, name, updateAt, {\r\n            argA: index,\r\n            argB: value,\r\n        }, updatedFieldArrayValuesWithKey, true, false);\r\n    };\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        control._isInAction.val = false;\r\n        if (control._names.watchAll) {\r\n            control._subjects.state.next({});\r\n        }\r\n        else {\r\n            for (const watchField of control._names.watch) {\r\n                if (name.startsWith(watchField)) {\r\n                    control._subjects.state.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        control._subjects.watch.next({\r\n            name,\r\n            values: control._formValues,\r\n        });\r\n        control._names.focus &&\r\n            focusFieldBy(control._fields, (key) => key.startsWith(control._names.focus));\r\n        control._names.focus = '';\r\n        control._proxyFormState.isValid && control._updateValid();\r\n    }, [fields, name, control, keyName]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const fieldArraySubscription = control._subjects.array.subscribe({\r\n            next({ values, name: fieldArrayName }) {\r\n                if (fieldArrayName === name || !fieldArrayName) {\r\n                    setFields(mapIds(get(values, name), keyName));\r\n                }\r\n            },\r\n        });\r\n        !get(control._formValues, name) && set(control._formValues, name, []);\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            if (control._shouldUnregister || shouldUnregister) {\r\n                control.unregister(name);\r\n            }\r\n        };\r\n    }, [name, control, keyName, shouldUnregister]);\r\n    return {\r\n        swap: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](swap, [name, control, keyName]),\r\n        move: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](move, [name, control, keyName]),\r\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](prepend$1, [name, control, keyName]),\r\n        append: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](append$1, [name, control, keyName]),\r\n        remove: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](remove, [name, control, keyName]),\r\n        insert: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](insert$1, [name, control, keyName]),\r\n        update: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](update, [name, control, keyName]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction cloneObject(data) {\r\n    let copy;\r\n    const isArray = Array.isArray(data);\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n    }\r\n    else if (isArray || isObject(data)) {\r\n        copy = isArray ? [] : {};\r\n        for (const key in data) {\r\n            copy[key] = cloneObject(data[key]);\r\n        }\r\n    }\r\n    else {\r\n        return data;\r\n    }\r\n    return copy;\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        isDateObject(object1) ||\r\n        isDateObject(object2)) {\r\n        return object1 === object2;\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        const val1 = object1[key];\r\n        if (!keys2.includes(key)) {\r\n            return false;\r\n        }\r\n        if (key !== 'ref') {\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || Array.isArray(val1)) &&\r\n                (isObject(val2) || Array.isArray(val2))\r\n                ? !deepEqual(val1, val2)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nvar isString = (value) => typeof value === 'string';\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nvar live = (ref) => !isHTMLElement(ref) || !document.contains(ref);\n\nvar omitKey = (fields, keyName) => fields.map((field = {}) => omit(field, keyName));\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (field._f.refs ? field._f.refs.every((ref) => ref.disabled) : ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar getResolverOptions = (fieldsNames, _fieldss, criteriaMode, shouldUseNativeValidation) => {\r\n    const fields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(_fieldss, name);\r\n        field && set(fields, name, field._f);\r\n    }\r\n    return {\r\n        criteriaMode,\r\n        names: [...fieldsNames],\r\n        fields,\r\n        shouldUseNativeValidation,\r\n    };\r\n};\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                !isNullOrUndefined(defaultValues) &&\r\n                    deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar unsetEmptyArray = (ref, name) => !compact(get(ref, name, [])).length && unset(ref, name);\n\nvar isMessage = (value) => isString(value) || react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"](value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async (field, inputValue, validateAllFieldCriteria, shouldUseNativeValidation) => {\r\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, } = field._f;\r\n    if (!mount || disabled) {\r\n        return {};\r\n    }\r\n    const inputRef = refs ? refs[0] : ref;\r\n    const setCustomValidty = (message) => {\r\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\r\n            inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');\r\n            inputRef.reportValidity();\r\n        }\r\n    };\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: inputRef }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((maxLength || minLength) && !isEmpty && isString(inputValue)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty && isString(inputValue)) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, inputRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    setCustomValidty(validateError.message);\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const key in validate) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateError = getValidateError(await validate[key](inputValue), inputRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    setCustomValidty(validateError.message);\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: inputRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setCustomValidty(true);\r\n    return error;\r\n};\n\nconst defaultOptions = {\r\n    mode: VALIDATION_MODE.onSubmit,\r\n    reValidateMode: VALIDATION_MODE.onChange,\r\n    shouldFocusError: true,\r\n};\r\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction createFormControl(props = {}) {\r\n    let formOptions = Object.assign(Object.assign({}, defaultOptions), props);\r\n    let _delayCallback;\r\n    let _formState = {\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    };\r\n    let _fields = {};\r\n    let _formValues = {};\r\n    let _defaultValues = formOptions.defaultValues || {};\r\n    let _isInAction = false;\r\n    let _isMounted = false;\r\n    let _timer = 0;\r\n    let _names = {\r\n        mount: new Set(),\r\n        unMount: new Set(),\r\n        array: new Set(),\r\n        watch: new Set(),\r\n    };\r\n    let _validateCount = {};\r\n    const _proxyFormState = {\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    };\r\n    const _subjects = {\r\n        watch: new Subject(),\r\n        control: new Subject(),\r\n        array: new Subject(),\r\n        state: new Subject(),\r\n    };\r\n    const validationMode = getValidationModes(formOptions.mode);\r\n    const isValidateAllFieldCriteria = formOptions.criteriaMode === VALIDATION_MODE.all;\r\n    const debounce = (callback, wait) => (...args) => {\r\n        clearTimeout(_timer);\r\n        _timer = window.setTimeout(() => callback(...args), wait);\r\n    };\r\n    const isFieldWatched = (name) => _names.watchAll ||\r\n        _names.watch.has(name) ||\r\n        _names.watch.has((name.match(/\\w+/) || [])[0]);\r\n    const updateErrorState = (name, error) => {\r\n        set(_formState.errors, name, error);\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const shouldRenderBaseOnValid = async () => {\r\n        const isValid = await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const shouldRenderBaseOnError = async (shouldSkipRender, name, error, fieldState, isValidFromResolver, isWatched) => {\r\n        const previousError = get(_formState.errors, name);\r\n        const isValid = !!(_proxyFormState.isValid &&\r\n            (formOptions.resolver ? isValidFromResolver : shouldRenderBaseOnValid()));\r\n        if (props.delayError && error) {\r\n            _delayCallback =\r\n                _delayCallback || debounce(updateErrorState, props.delayError);\r\n            _delayCallback(name, error);\r\n        }\r\n        else {\r\n            clearTimeout(_timer);\r\n            error\r\n                ? set(_formState.errors, name, error)\r\n                : unset(_formState.errors, name);\r\n        }\r\n        if ((isWatched ||\r\n            (error ? !deepEqual(previousError, error) : previousError) ||\r\n            !isEmptyObject(fieldState) ||\r\n            _formState.isValid !== isValid) &&\r\n            !shouldSkipRender) {\r\n            const updatedFormState = Object.assign(Object.assign(Object.assign({}, fieldState), (_proxyFormState.isValid && formOptions.resolver ? { isValid } : {})), { errors: _formState.errors, name });\r\n            _formState = Object.assign(Object.assign({}, _formState), updatedFormState);\r\n            _subjects.state.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        _validateCount[name]--;\r\n        if (!_validateCount[name]) {\r\n            _subjects.state.next({\r\n                isValidating: false,\r\n            });\r\n            _validateCount = {};\r\n        }\r\n    };\r\n    const setFieldValue = (name, value, options = {}, shouldRender) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                set(_formValues, name, getFieldValueAs(value, _f));\r\n                const fieldValue = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(value)\r\n                    ? ''\r\n                    : value;\r\n                if (isFileInput(_f.ref) && !isString(fieldValue)) {\r\n                    _f.ref.files = fieldValue;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = fieldValue.includes(selectRef.value)));\r\n                }\r\n                else if (_f.refs) {\r\n                    if (isCheckBoxInput(_f.ref)) {\r\n                        _f.refs.length > 1\r\n                            ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(fieldValue)\r\n                                ? !!fieldValue.find((data) => data === checkboxRef.value)\r\n                                : fieldValue === checkboxRef.value))\r\n                            : (_f.refs[0].checked = !!fieldValue);\r\n                    }\r\n                    else {\r\n                        _f.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));\r\n                    }\r\n                }\r\n                else {\r\n                    _f.ref.value = fieldValue;\r\n                }\r\n                if (shouldRender) {\r\n                    _subjects.control.next({\r\n                        values: getValues(),\r\n                        name,\r\n                    });\r\n                }\r\n                (options.shouldDirty || options.shouldTouch) &&\r\n                    updateTouchAndDirtyState(name, fieldValue, options.shouldTouch);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n        }\r\n    };\r\n    const updateTouchAndDirtyState = (name, inputValue, isCurrentTouched, shouldRender = true) => {\r\n        const state = {\r\n            name,\r\n        };\r\n        let isChanged = false;\r\n        if (_proxyFormState.isDirty) {\r\n            const previousIsDirty = _formState.isDirty;\r\n            _formState.isDirty = _getIsDirty();\r\n            state.isDirty = _formState.isDirty;\r\n            isChanged = previousIsDirty !== state.isDirty;\r\n        }\r\n        if (_proxyFormState.dirtyFields && !isCurrentTouched) {\r\n            const isPreviousFieldDirty = get(_formState.dirtyFields, name);\r\n            const isCurrentFieldDirty = !deepEqual(get(_defaultValues, name), inputValue);\r\n            isCurrentFieldDirty\r\n                ? set(_formState.dirtyFields, name, true)\r\n                : unset(_formState.dirtyFields, name);\r\n            state.dirtyFields = _formState.dirtyFields;\r\n            isChanged =\r\n                isChanged || isPreviousFieldDirty !== get(_formState.dirtyFields, name);\r\n        }\r\n        const isPreviousFieldTouched = get(_formState.touchedFields, name);\r\n        if (isCurrentTouched && !isPreviousFieldTouched) {\r\n            set(_formState.touchedFields, name, isCurrentTouched);\r\n            state.touchedFields = _formState.touchedFields;\r\n            isChanged =\r\n                isChanged ||\r\n                    (_proxyFormState.touchedFields &&\r\n                        isPreviousFieldTouched !== isCurrentTouched);\r\n        }\r\n        isChanged && shouldRender && _subjects.state.next(state);\r\n        return isChanged ? state : {};\r\n    };\r\n    const executeResolver = async (name) => {\r\n        return formOptions.resolver\r\n            ? await formOptions.resolver(Object.assign({}, _formValues), formOptions.context, getResolverOptions(name || _names.mount, _fields, formOptions.criteriaMode, formOptions.shouldUseNativeValidation))\r\n            : {};\r\n    };\r\n    const executeResolverValidation = async (names) => {\r\n        const { errors } = await executeResolver();\r\n        if (names) {\r\n            for (const name of names) {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(_formState.errors, name, error)\r\n                    : unset(_formState.errors, name);\r\n            }\r\n        }\r\n        else {\r\n            _formState.errors = errors;\r\n        }\r\n        return errors;\r\n    };\r\n    const validateForm = async (_fields, shouldCheckValid, context = {\r\n        valid: true,\r\n    }) => {\r\n        for (const name in _fields) {\r\n            const field = _fields[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const val = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, get(_formValues, _f.name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation);\r\n                    if (shouldCheckValid) {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                        }\r\n                        fieldError[_f.name]\r\n                            ? set(_formState.errors, _f.name, fieldError[_f.name])\r\n                            : unset(_formState.errors, _f.name);\r\n                    }\r\n                }\r\n                val && (await validateForm(val, shouldCheckValid, context));\r\n            }\r\n        }\r\n        return context.valid;\r\n    };\r\n    const handleChange = async ({ type, target, target: { value, name, type: inputType }, }) => {\r\n        let error;\r\n        let isValid;\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange } = getValidationModes(formOptions.reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !formOptions.resolver &&\r\n                !get(_formState.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(_formState.touchedFields, name), isSubmitted: _formState.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                set(_formValues, name, inputValue);\r\n            }\r\n            const fieldState = updateTouchAndDirtyState(name, inputValue, isBlurEvent, false);\r\n            const shouldRender = !isEmptyObject(fieldState) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    _subjects.watch.next({\r\n                        name,\r\n                        type,\r\n                    });\r\n                return (shouldRender &&\r\n                    _subjects.state.next(isWatched ? { name } : Object.assign(Object.assign({}, fieldState), { name })));\r\n            }\r\n            _validateCount[name] = _validateCount[name] ? +1 : 1;\r\n            _subjects.state.next({\r\n                isValidating: true,\r\n            });\r\n            if (formOptions.resolver) {\r\n                const { errors } = await executeResolver([name]);\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const valError = get(errors, parentNodeName, {});\r\n                    valError.type && valError.message && (error = valError);\r\n                    if (valError || get(_formState.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n            }\r\n            else {\r\n                error = (await validateField(field, get(_formValues, name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                _subjects.watch.next({\r\n                    name,\r\n                    type,\r\n                    values: getValues(),\r\n                });\r\n            shouldRenderBaseOnError(false, name, error, fieldState, isValid, isWatched);\r\n        }\r\n    };\r\n    const _updateValidAndInputValue = (name, ref, shouldSkipValueAs) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const fieldValue = get(_formValues, name);\r\n            const isValueUndefined = isUndefined(fieldValue);\r\n            const defaultValue = isValueUndefined\r\n                ? get(_defaultValues, name)\r\n                : fieldValue;\r\n            if (isUndefined(defaultValue) ||\r\n                (ref && ref.defaultChecked) ||\r\n                shouldSkipValueAs) {\r\n                set(_formValues, name, shouldSkipValueAs ? defaultValue : getFieldValue(field));\r\n            }\r\n            else {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        _isMounted && _proxyFormState.isValid && _updateValid();\r\n    };\r\n    const _getIsDirty = (name, data) => {\r\n        name && data && set(_formValues, name, data);\r\n        return !deepEqual(Object.assign({}, getValues()), _defaultValues);\r\n    };\r\n    const _updateValid = async () => {\r\n        const isValid = formOptions.resolver\r\n            ? isEmptyObject((await executeResolver()).errors)\r\n            : await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const setValues = (name, value, options) => Object.entries(value).forEach(([fieldKey, fieldValue]) => {\r\n        const fieldName = `${name}.${fieldKey}`;\r\n        const field = get(_fields, fieldName);\r\n        const isFieldArray = _names.array.has(name);\r\n        (isFieldArray || !isPrimitive(fieldValue) || (field && !field._f)) &&\r\n            !isDateObject(fieldValue)\r\n            ? setValues(fieldName, fieldValue, options)\r\n            : setFieldValue(fieldName, fieldValue, options, true);\r\n    });\r\n    const _getWatch = (fieldNames, defaultValue, isGlobal) => {\r\n        const fieldValues = Object.assign({}, (_isMounted\r\n            ? _formValues\r\n            : isUndefined(defaultValue)\r\n                ? _defaultValues\r\n                : isString(fieldNames)\r\n                    ? { [fieldNames]: defaultValue }\r\n                    : defaultValue));\r\n        if (!fieldNames) {\r\n            isGlobal && (_names.watchAll = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && _names.watch.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return Array.isArray(fieldNames)\r\n            ? result\r\n            : isObject(result[0])\r\n                ? Object.assign({}, result[0]) : Array.isArray(result[0])\r\n                ? [...result[0]]\r\n                : result[0];\r\n    };\r\n    const _updateValues = (defaultValues, name = '') => {\r\n        for (const key in defaultValues) {\r\n            const value = defaultValues[key];\r\n            const fieldName = name + (name ? '.' : '') + key;\r\n            const field = get(_fields, fieldName);\r\n            if (!field || !field._f) {\r\n                if (isObject(value) || Array.isArray(value)) {\r\n                    _updateValues(value, fieldName);\r\n                }\r\n                else if (!field) {\r\n                    set(_formValues, fieldName, value);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const _updateFieldArray = (keyName, name, method, args, updatedFieldArrayValuesWithKey = [], shouldSet = true, shouldSetFields = true) => {\r\n        let output;\r\n        const updatedFieldArrayValues = omitKey(updatedFieldArrayValuesWithKey, keyName);\r\n        _isInAction = true;\r\n        if (shouldSetFields && get(_fields, name)) {\r\n            output = method(get(_fields, name), args.argA, args.argB);\r\n            shouldSet && set(_fields, name, output);\r\n        }\r\n        output = method(get(_formValues, name), args.argA, args.argB);\r\n        shouldSet && set(_formValues, name, output);\r\n        if (Array.isArray(get(_formState.errors, name))) {\r\n            const output = method(get(_formState.errors, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.errors, name, output);\r\n            unsetEmptyArray(_formState.errors, name);\r\n        }\r\n        if (_proxyFormState.touchedFields && get(_formState.touchedFields, name)) {\r\n            const output = method(get(_formState.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.touchedFields, name, output);\r\n            unsetEmptyArray(_formState.touchedFields, name);\r\n        }\r\n        if (_proxyFormState.dirtyFields || _proxyFormState.isDirty) {\r\n            set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            updatedFieldArrayValues &&\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            unsetEmptyArray(_formState.dirtyFields, name);\r\n        }\r\n        _subjects.state.next({\r\n            isDirty: _getIsDirty(name, omitKey(updatedFieldArrayValues, keyName)),\r\n            dirtyFields: _formState.dirtyFields,\r\n            errors: _formState.errors,\r\n            isValid: _formState.isValid,\r\n        });\r\n    };\r\n    const _getFieldArrayValue = (name) => get(_isMounted ? _formValues : _defaultValues, name, []);\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(_fields, name);\r\n        const isFieldArray = _names.array.has(name);\r\n        set(_formValues, name, value);\r\n        if (isFieldArray) {\r\n            _subjects.array.next({\r\n                name,\r\n                values: _formValues,\r\n            });\r\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(value, get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n                _subjects.state.next({\r\n                    name,\r\n                    dirtyFields: _formState.dirtyFields,\r\n                    isDirty: _getIsDirty(name, value),\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            field && !field._f && !isNullOrUndefined(value)\r\n                ? setValues(name, value, options)\r\n                : setFieldValue(name, value, options, true);\r\n        }\r\n        isFieldWatched(name) && _subjects.state.next({});\r\n        _subjects.watch.next({\r\n            name,\r\n        });\r\n    };\r\n    const trigger = async (name, options = {}) => {\r\n        const fieldNames = convertToArrayPayload(name);\r\n        let isValid;\r\n        _subjects.state.next({\r\n            isValidating: true,\r\n        });\r\n        if (formOptions.resolver) {\r\n            const schemaResult = await executeResolverValidation(isUndefined(name) ? name : fieldNames);\r\n            isValid = name\r\n                ? fieldNames.every((name) => !get(schemaResult, name))\r\n                : isEmptyObject(schemaResult);\r\n        }\r\n        else {\r\n            if (name) {\r\n                isValid = (await Promise.all(fieldNames.map(async (fieldName) => {\r\n                    const field = get(_fields, fieldName);\r\n                    return await validateForm(field._f ? { [fieldName]: field } : field);\r\n                }))).every(Boolean);\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n                isValid = isEmptyObject(_formState.errors);\r\n            }\r\n        }\r\n        _subjects.state.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: _formState.errors, isValidating: false }));\r\n        if (options.shouldFocus && !isValid) {\r\n            focusFieldBy(_fields, (key) => get(_formState.errors, key), name ? fieldNames : _names.mount);\r\n        }\r\n        _proxyFormState.isValid && _updateValid();\r\n        return isValid;\r\n    };\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, _defaultValues), _formValues);\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName))\r\n            : (_formState.errors = {});\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;\r\n        set(_formState.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        _subjects.state.next({\r\n            name,\r\n            errors: _formState.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? _subjects.watch.subscribe({\r\n            next: (info) => fieldName(_getWatch(undefined, defaultValue), info),\r\n        })\r\n        : _getWatch(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name ? convertToArrayPayload(name) : _names.mount) {\r\n            _names.mount.delete(inputName);\r\n            _names.array.delete(inputName);\r\n            if (get(_fields, inputName)) {\r\n                if (!options.keepValue) {\r\n                    unset(_fields, inputName);\r\n                    unset(_formValues, inputName);\r\n                }\r\n                !options.keepError && unset(_formState.errors, inputName);\r\n                !options.keepDirty && unset(_formState.dirtyFields, inputName);\r\n                !options.keepTouched && unset(_formState.touchedFields, inputName);\r\n                !formOptions.shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(_defaultValues, inputName);\r\n            }\r\n        }\r\n        _subjects.watch.next({});\r\n        _subjects.state.next(Object.assign(Object.assign({}, _formState), (!options.keepDirty ? {} : { isDirty: _getIsDirty() })));\r\n        !options.keepIsValid && _updateValid();\r\n    };\r\n    const registerFieldRef = (name, fieldRef, options) => {\r\n        register(name, options);\r\n        let field = get(_fields, name);\r\n        const ref = isUndefined(fieldRef.value)\r\n            ? fieldRef.querySelectorAll\r\n                ? fieldRef.querySelectorAll('input,select,textarea')[0] ||\r\n                    fieldRef\r\n                : fieldRef\r\n            : fieldRef;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isRadioOrCheckbox &&\r\n                compact(field._f.refs || []).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(_fields, name, field);\r\n        _updateValidAndInputValue(name, ref);\r\n    };\r\n    const register = (name, options = {}) => {\r\n        const field = get(_fields, name);\r\n        set(_fields, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        if (options.value) {\r\n            set(_formValues, name, options.value);\r\n        }\r\n        if (!isUndefined(options.disabled) &&\r\n            field &&\r\n            field._f &&\r\n            field._f.ref.disabled !== options.disabled) {\r\n            set(_formValues, name, options.disabled ? undefined : field._f.ref.value);\r\n        }\r\n        _names.mount.add(name);\r\n        !field && _updateValidAndInputValue(name, undefined, true);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : Object.assign(Object.assign({ name }, (isUndefined(options.disabled)\r\n                ? {}\r\n                : { disabled: options.disabled })), { onChange: handleChange, onBlur: handleChange, ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(_fields, name, {});\r\n                        const _shouldUnregister = formOptions.shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                        }\r\n                        _shouldUnregister &&\r\n                            !(isNameInFieldArray(_names.array, name) && _isInAction) &&\r\n                            _names.unMount.add(name);\r\n                    }\r\n                } });\r\n    };\r\n    const handleSubmit = (onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = Object.assign({}, _formValues);\r\n        _subjects.state.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (formOptions.resolver) {\r\n                const { errors, values } = await executeResolver();\r\n                _formState.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n            }\r\n            if (isEmptyObject(_formState.errors) &&\r\n                Object.keys(_formState.errors).every((name) => get(fieldValues, name))) {\r\n                _subjects.state.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(_formState.errors, e));\r\n                formOptions.shouldFocusError &&\r\n                    focusFieldBy(_fields, (key) => get(_formState.errors, key), _names.mount);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            _formState.isSubmitted = true;\r\n            _subjects.state.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && hasNoPromiseError,\r\n                submitCount: _formState.submitCount + 1,\r\n                errors: _formState.errors,\r\n            });\r\n        }\r\n    };\r\n    const reset = (formValues, keepStateOptions = {}) => {\r\n        const updatedValues = formValues || _defaultValues;\r\n        const values = cloneObject(updatedValues);\r\n        _formValues = values;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of _names.mount) {\r\n                const field = get(_fields, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        if (!keepStateOptions.keepDefaultValues) {\r\n            _defaultValues = Object.assign({}, updatedValues);\r\n        }\r\n        if (!keepStateOptions.keepValues) {\r\n            _fields = {};\r\n            _subjects.control.next({\r\n                values: keepStateOptions.keepDefaultValues\r\n                    ? _defaultValues\r\n                    : Object.assign({}, updatedValues),\r\n            });\r\n            _subjects.watch.next({});\r\n            _subjects.array.next({\r\n                values,\r\n            });\r\n        }\r\n        _names = {\r\n            mount: new Set(),\r\n            unMount: new Set(),\r\n            array: new Set(),\r\n            watch: new Set(),\r\n            watchAll: false,\r\n            focus: '',\r\n        };\r\n        _subjects.state.next({\r\n            submitCount: keepStateOptions.keepSubmitCount\r\n                ? _formState.submitCount\r\n                : 0,\r\n            isDirty: keepStateOptions.keepDirty\r\n                ? _formState.isDirty\r\n                : keepStateOptions.keepDefaultValues\r\n                    ? deepEqual(formValues, _defaultValues)\r\n                    : false,\r\n            isSubmitted: keepStateOptions.keepIsSubmitted\r\n                ? _formState.isSubmitted\r\n                : false,\r\n            dirtyFields: keepStateOptions.keepDirty ? _formState.dirtyFields : {},\r\n            touchedFields: keepStateOptions.keepTouched\r\n                ? _formState.touchedFields\r\n                : {},\r\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n        _isMounted = !!keepStateOptions.keepIsValid;\r\n    };\r\n    const setFocus = (name) => get(_fields, name)._f.ref.focus();\r\n    const _removeFields = () => {\r\n        for (const name of _names.unMount) {\r\n            const field = get(_fields, name);\r\n            field &&\r\n                (field._f.refs ? field._f.refs.every(live) : live(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        _names.unMount = new Set();\r\n    };\r\n    return {\r\n        control: {\r\n            register,\r\n            unregister,\r\n            _getWatch,\r\n            _getIsDirty,\r\n            _updateValid,\r\n            _updateValues,\r\n            _removeFields,\r\n            _updateFieldArray,\r\n            _getFieldArrayValue,\r\n            _subjects,\r\n            _shouldUnregister: formOptions.shouldUnregister,\r\n            _fields,\r\n            _proxyFormState,\r\n            get _formValues() {\r\n                return _formValues;\r\n            },\r\n            set _formValues(value) {\r\n                _formValues = value;\r\n            },\r\n            get _isMounted() {\r\n                return _isMounted;\r\n            },\r\n            set _isMounted(value) {\r\n                _isMounted = value;\r\n            },\r\n            get _defaultValues() {\r\n                return _defaultValues;\r\n            },\r\n            set _defaultValues(value) {\r\n                _defaultValues = value;\r\n            },\r\n            get _names() {\r\n                return _names;\r\n            },\r\n            set _names(value) {\r\n                _names = value;\r\n            },\r\n            _isInAction: {\r\n                get val() {\r\n                    return _isInAction;\r\n                },\r\n                set val(value) {\r\n                    _isInAction = value;\r\n                },\r\n            },\r\n            _formState: {\r\n                get val() {\r\n                    return _formState;\r\n                },\r\n                set val(value) {\r\n                    _formState = value;\r\n                },\r\n            },\r\n            _updateProps: (options) => {\r\n                formOptions = Object.assign(Object.assign({}, defaultOptions), options);\r\n            },\r\n        },\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch,\r\n        setValue,\r\n        getValues,\r\n        reset,\r\n        clearErrors,\r\n        unregister,\r\n        setError,\r\n        setFocus,\r\n    };\r\n}\n\nfunction useForm(props = {}) {\r\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]();\r\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"]({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    });\r\n    if (_formControl.current) {\r\n        _formControl.current.control._updateProps(props);\r\n    }\r\n    else {\r\n        _formControl.current = Object.assign(Object.assign({}, createFormControl(props)), { formState });\r\n    }\r\n    const control = _formControl.current.control;\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, control._proxyFormState, true)) {\r\n                    control._formState.val = Object.assign(Object.assign({}, control._formState.val), formState);\r\n                    updateFormState(Object.assign({}, control._formState.val));\r\n                }\r\n            },\r\n        });\r\n        return () => {\r\n            formStateSubscription.unsubscribe();\r\n        };\r\n    }, [control]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        if (!control._isMounted) {\r\n            control._isMounted = true;\r\n            control._proxyFormState.isValid && control._updateValid();\r\n            !props.shouldUnregister && control._updateValues(control._defaultValues);\r\n        }\r\n        control._removeFields();\r\n    });\r\n    _formControl.current.formState = getProxyFormState(formState, control._proxyFormState);\r\n    return _formControl.current;\r\n}\n\nfunction useWatch(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, defaultValue, disabled, } = props || {};\r\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](name);\r\n    _name.current = name;\r\n    const [value, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](isUndefined(defaultValue)\r\n        ? control._getWatch(name)\r\n        : defaultValue);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const watchSubscription = control._subjects.watch.subscribe({\r\n            next: ({ name }) => {\r\n                (!_name.current ||\r\n                    !name ||\r\n                    convertToArrayPayload(_name.current).some((fieldName) => name &&\r\n                        fieldName &&\r\n                        (fieldName.startsWith(name) ||\r\n                            name.startsWith(fieldName)))) &&\r\n                    updateValue(control._getWatch(_name.current, defaultValue));\r\n            },\r\n        });\r\n        disabled && watchSubscription.unsubscribe();\r\n        return () => watchSubscription.unsubscribe();\r\n    }, [disabled, control, defaultValue]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        control._removeFields();\r\n    });\r\n    return value;\r\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n/***/ }),\n\n/***/ \"cpVT\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return _defineProperty; });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/home/whiteshadow/projects/benchmark-advisors/node_modules/react-hook-form/dist/index.esm.js","/home/whiteshadow/projects/benchmark-advisors/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+B;;AAE/B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,oBAAoB,mDAAmB;AACvC;AACA,6BAA6B,gDAAgB;AAC7C,iCAAiC,mDAAmB,wBAAwB,iCAAiC;;AAE7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,4CAA4C;AACvD,oBAAoB,4CAAY;AAChC,yCAAyC,8CAAc;AACvD,iCAAiC,4CAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,+CAAe;AACnB;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,oDAAoD;AAC/D,wCAAwC,8CAAc;AACtD;AACA;AACA;AACA,KAAK;AACL,+EAA+E,iBAAiB,QAAQ;AACxG,0BAA0B,iDAAiB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,oCAAoC,kBAAkB,sCAAsC,+DAA+D,KAAK,0BAA0B,GAAG;;AAE7L;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,KAAK,GAAG,mBAAmB;AACzD,SAAS,KAAK,GAAG,MAAM;;AAEvB;AACA;AACA,yCAAyC,qBAAqB,6BAA6B,KAAK;AAChG,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,4FAA4F,sBAAsB,IAAI,0BAA0B;;AAEhJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,qEAAqE;AAChF,gCAAgC,8CAAc;AAC9C,sBAAsB,4CAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,+CAAe;AACnB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,iDAAiB;AAC/B,cAAc,iDAAiB;AAC/B,iBAAiB,iDAAiB;AAClC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,yDAAyD;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,WAAW,QAAQ;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,iFAAiF;AACjF;AACA;AACA;AACA,4DAA4D;AAC5D,kDAAkD;AAClD,0EAA0E,wBAAwB,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2HAA2H;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,oDAAoB;;AAElE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,gHAAgH;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe;AACf;AACA;AACA,yCAAyC,gEAAgE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,oDAAoD;AACpD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,mEAAmE,UAAU,KAAK,KAAK,kCAAkC;AAC1M,uDAAuD;AACvD,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,+BAA+B,GAAG;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAiE;AACpF;AACA;AACA;AACA,8CAA8C;AAC9C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sDAAsD,OAAO,iCAAiC,gBAAgB,OAAO;AACrH;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B,KAAK,GAAG,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,SAAS;AACT;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,qBAAqB,OAAO,KAAK,KAAK,iDAAiD;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,OAAO,EAAE,UAAU;AAC5D,mEAAmE,WAAW,MAAM;AACpF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,2DAA2D,uCAAuC,IAAI,yBAAyB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA,6BAA6B,uBAAuB,EAAE,kCAAkC,cAAc,MAAM;AAC5G;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,4DAA4D,mCAAmC,OAAO,OAAO,EAAE,KAAK,oBAAoB;AACxI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,2CAA2C,OAAO;AAClD;AACA,mBAAmB,6BAA6B,KAAK;AACrD;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,aAAa;AACb,mCAAmC;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA,oBAAoB;AACpB,wEAAwE;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,4DAA4D;AAC5D,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,yBAAyB,4CAAY;AACrC,yCAAyC,8CAAc;AACvD;AACA;AACA,uBAAuB;AACvB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL;AACA;AACA;AACA;AACA,6DAA6D,8BAA8B,YAAY;AACvG;AACA;AACA,IAAI,+CAAe;AACnB;AACA;AACA;AACA,2EAA2E;AAC3E,oDAAoD;AACpD;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,2DAA2D;AACtE,kBAAkB,4CAAY;AAC9B;AACA,iCAAiC,8CAAc;AAC/C;AACA;AACA,IAAI,+CAAe;AACnB;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA,KAAK;AACL;AACA;;AAE2I;AAC3I;;;;;;;;;ACzvDA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA,C","file":"x","sourcesContent":["import * as React from 'react';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isDateObject = (data) => data instanceof Date;\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !isDateObject(value);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = React.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => React.useContext(FormContext);\r\nconst FormProvider = (props) => (React.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (formState, _proxyFormState, localProxyFormState, isRoot = true) => {\r\n    function createGetter(prop) {\r\n        return () => {\r\n            if (prop in formState) {\r\n                if (_proxyFormState[prop] !== VALIDATION_MODE.all) {\r\n                    _proxyFormState[prop] = !isRoot || VALIDATION_MODE.all;\r\n                }\r\n                localProxyFormState && (localProxyFormState[prop] = true);\r\n                return formState[prop];\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n    const result = {};\r\n    for (const key in formState) {\r\n        Object.defineProperty(result, key, {\r\n            get: createGetter(key),\r\n        });\r\n    }\r\n    return result;\r\n};\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, _proxyFormState, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||\r\n        Object.keys(formState).find((key) => _proxyFormState[key] ===\r\n            (!isRoot || VALIDATION_MODE.all)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, disabled, name } = props || {};\r\n    const nameRef = React.useRef(name);\r\n    const [formState, updateFormState] = React.useState(control._formState.val);\r\n    const _localProxyFormState = React.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    nameRef.current = name;\r\n    React.useEffect(() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, _localProxyFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, control._formState.val), formState)),\r\n        });\r\n        disabled && formStateSubscription.unsubscribe();\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, [disabled, control]);\r\n    return getProxyFormState(formState, control._proxyFormState, _localProxyFormState.current, false);\r\n}\n\nfunction useController(props) {\r\n    const methods = useFormContext();\r\n    const { name, control = methods.control, shouldUnregister } = props;\r\n    const [value, setInputStateValue] = React.useState(get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)));\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    const registerProps = control.register(name, Object.assign(Object.assign({}, props.rules), { value }));\r\n    const updateMounted = React.useCallback((name, value) => {\r\n        const field = get(control._fields, name);\r\n        if (field) {\r\n            field._f.mount = value;\r\n        }\r\n    }, [control]);\r\n    React.useEffect(() => {\r\n        const controllerSubscription = control._subjects.control.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        updateMounted(name, true);\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const _shouldUnregisterField = control._shouldUnregister || shouldUnregister;\r\n            if (isNameInFieldArray(control._names.array, name)\r\n                ? _shouldUnregisterField && !control._isInAction.val\r\n                : _shouldUnregisterField) {\r\n                control.unregister(name);\r\n            }\r\n            else {\r\n                updateMounted(name, false);\r\n            }\r\n        };\r\n    }, [name, control, shouldUnregister, updateMounted]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                registerProps.onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                registerProps.onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm &&\r\n                registerProps.ref({\r\n                    focus: () => elm.focus && elm.focus(),\r\n                    setCustomValidity: (message) => elm.setCustomValidity(message),\r\n                    reportValidity: () => elm.reportValidity(),\r\n                }),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nvar getFocusFieldName = (name, index, options) => options && !options.shouldFocus\r\n    ? options.focusName || `${name}.${options.focusIndex}.`\r\n    : `${name}.${index}.`;\n\nvar mapCurrentIds = (values, _fieldIds, keyName) => values.map((value, index) => {\r\n    const output = _fieldIds.current[index];\r\n    return Object.assign(Object.assign({}, value), (output ? { [keyName]: output[keyName] } : {}));\r\n});\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign(Object.assign({}, (value[keyName] ? {} : { [keyName]: generateId() })), value)));\n\nfunction append(data, value) {\r\n    return [...convertToArrayPayload(data), ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...convertToArrayPayload(data)];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar updateAt = (fieldValues, index, value) => {\r\n    fieldValues[index] = value;\r\n    return fieldValues;\r\n};\n\nconst useFieldArray = (props) => {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, keyName = 'id', shouldUnregister, } = props;\r\n    const [fields, setFields] = React.useState(mapIds(control._getFieldArrayValue(name), keyName));\r\n    const _fieldIds = React.useRef(fields);\r\n    _fieldIds.current = fields;\r\n    control._names.array.add(name);\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValuesWithKey = append(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValuesWithKey.length - appendValue.length, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const updatedFieldArrayValuesWithKey = prepend(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, 0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValuesWithKey = removeArrayAt(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValuesWithKey);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const updatedFieldArrayValuesWithKey = insert(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index, mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        swapArrayAt(updatedFieldArrayValuesWithKey, indexA, indexB);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        moveArrayAt(updatedFieldArrayValuesWithKey, from, to);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const update = (index, value) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        const updatedFieldArrayValues = updateAt(updatedFieldArrayValuesWithKey, index, value);\r\n        _fieldIds.current = mapIds(updatedFieldArrayValues, keyName);\r\n        setFields(_fieldIds.current);\r\n        control._updateFieldArray(keyName, name, updateAt, {\r\n            argA: index,\r\n            argB: value,\r\n        }, updatedFieldArrayValuesWithKey, true, false);\r\n    };\r\n    React.useEffect(() => {\r\n        control._isInAction.val = false;\r\n        if (control._names.watchAll) {\r\n            control._subjects.state.next({});\r\n        }\r\n        else {\r\n            for (const watchField of control._names.watch) {\r\n                if (name.startsWith(watchField)) {\r\n                    control._subjects.state.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        control._subjects.watch.next({\r\n            name,\r\n            values: control._formValues,\r\n        });\r\n        control._names.focus &&\r\n            focusFieldBy(control._fields, (key) => key.startsWith(control._names.focus));\r\n        control._names.focus = '';\r\n        control._proxyFormState.isValid && control._updateValid();\r\n    }, [fields, name, control, keyName]);\r\n    React.useEffect(() => {\r\n        const fieldArraySubscription = control._subjects.array.subscribe({\r\n            next({ values, name: fieldArrayName }) {\r\n                if (fieldArrayName === name || !fieldArrayName) {\r\n                    setFields(mapIds(get(values, name), keyName));\r\n                }\r\n            },\r\n        });\r\n        !get(control._formValues, name) && set(control._formValues, name, []);\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            if (control._shouldUnregister || shouldUnregister) {\r\n                control.unregister(name);\r\n            }\r\n        };\r\n    }, [name, control, keyName, shouldUnregister]);\r\n    return {\r\n        swap: React.useCallback(swap, [name, control, keyName]),\r\n        move: React.useCallback(move, [name, control, keyName]),\r\n        prepend: React.useCallback(prepend$1, [name, control, keyName]),\r\n        append: React.useCallback(append$1, [name, control, keyName]),\r\n        remove: React.useCallback(remove, [name, control, keyName]),\r\n        insert: React.useCallback(insert$1, [name, control, keyName]),\r\n        update: React.useCallback(update, [name, control, keyName]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction cloneObject(data) {\r\n    let copy;\r\n    const isArray = Array.isArray(data);\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n    }\r\n    else if (isArray || isObject(data)) {\r\n        copy = isArray ? [] : {};\r\n        for (const key in data) {\r\n            copy[key] = cloneObject(data[key]);\r\n        }\r\n    }\r\n    else {\r\n        return data;\r\n    }\r\n    return copy;\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        isDateObject(object1) ||\r\n        isDateObject(object2)) {\r\n        return object1 === object2;\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        const val1 = object1[key];\r\n        if (!keys2.includes(key)) {\r\n            return false;\r\n        }\r\n        if (key !== 'ref') {\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || Array.isArray(val1)) &&\r\n                (isObject(val2) || Array.isArray(val2))\r\n                ? !deepEqual(val1, val2)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nvar isString = (value) => typeof value === 'string';\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nvar live = (ref) => !isHTMLElement(ref) || !document.contains(ref);\n\nvar omitKey = (fields, keyName) => fields.map((field = {}) => omit(field, keyName));\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (field._f.refs ? field._f.refs.every((ref) => ref.disabled) : ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar getResolverOptions = (fieldsNames, _fieldss, criteriaMode, shouldUseNativeValidation) => {\r\n    const fields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(_fieldss, name);\r\n        field && set(fields, name, field._f);\r\n    }\r\n    return {\r\n        criteriaMode,\r\n        names: [...fieldsNames],\r\n        fields,\r\n        shouldUseNativeValidation,\r\n    };\r\n};\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                !isNullOrUndefined(defaultValues) &&\r\n                    deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar unsetEmptyArray = (ref, name) => !compact(get(ref, name, [])).length && unset(ref, name);\n\nvar isMessage = (value) => isString(value) || React.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async (field, inputValue, validateAllFieldCriteria, shouldUseNativeValidation) => {\r\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, } = field._f;\r\n    if (!mount || disabled) {\r\n        return {};\r\n    }\r\n    const inputRef = refs ? refs[0] : ref;\r\n    const setCustomValidty = (message) => {\r\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\r\n            inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');\r\n            inputRef.reportValidity();\r\n        }\r\n    };\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: inputRef }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((maxLength || minLength) && !isEmpty && isString(inputValue)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty && isString(inputValue)) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, inputRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    setCustomValidty(validateError.message);\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const key in validate) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateError = getValidateError(await validate[key](inputValue), inputRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    setCustomValidty(validateError.message);\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: inputRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setCustomValidty(true);\r\n    return error;\r\n};\n\nconst defaultOptions = {\r\n    mode: VALIDATION_MODE.onSubmit,\r\n    reValidateMode: VALIDATION_MODE.onChange,\r\n    shouldFocusError: true,\r\n};\r\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction createFormControl(props = {}) {\r\n    let formOptions = Object.assign(Object.assign({}, defaultOptions), props);\r\n    let _delayCallback;\r\n    let _formState = {\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    };\r\n    let _fields = {};\r\n    let _formValues = {};\r\n    let _defaultValues = formOptions.defaultValues || {};\r\n    let _isInAction = false;\r\n    let _isMounted = false;\r\n    let _timer = 0;\r\n    let _names = {\r\n        mount: new Set(),\r\n        unMount: new Set(),\r\n        array: new Set(),\r\n        watch: new Set(),\r\n    };\r\n    let _validateCount = {};\r\n    const _proxyFormState = {\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    };\r\n    const _subjects = {\r\n        watch: new Subject(),\r\n        control: new Subject(),\r\n        array: new Subject(),\r\n        state: new Subject(),\r\n    };\r\n    const validationMode = getValidationModes(formOptions.mode);\r\n    const isValidateAllFieldCriteria = formOptions.criteriaMode === VALIDATION_MODE.all;\r\n    const debounce = (callback, wait) => (...args) => {\r\n        clearTimeout(_timer);\r\n        _timer = window.setTimeout(() => callback(...args), wait);\r\n    };\r\n    const isFieldWatched = (name) => _names.watchAll ||\r\n        _names.watch.has(name) ||\r\n        _names.watch.has((name.match(/\\w+/) || [])[0]);\r\n    const updateErrorState = (name, error) => {\r\n        set(_formState.errors, name, error);\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const shouldRenderBaseOnValid = async () => {\r\n        const isValid = await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const shouldRenderBaseOnError = async (shouldSkipRender, name, error, fieldState, isValidFromResolver, isWatched) => {\r\n        const previousError = get(_formState.errors, name);\r\n        const isValid = !!(_proxyFormState.isValid &&\r\n            (formOptions.resolver ? isValidFromResolver : shouldRenderBaseOnValid()));\r\n        if (props.delayError && error) {\r\n            _delayCallback =\r\n                _delayCallback || debounce(updateErrorState, props.delayError);\r\n            _delayCallback(name, error);\r\n        }\r\n        else {\r\n            clearTimeout(_timer);\r\n            error\r\n                ? set(_formState.errors, name, error)\r\n                : unset(_formState.errors, name);\r\n        }\r\n        if ((isWatched ||\r\n            (error ? !deepEqual(previousError, error) : previousError) ||\r\n            !isEmptyObject(fieldState) ||\r\n            _formState.isValid !== isValid) &&\r\n            !shouldSkipRender) {\r\n            const updatedFormState = Object.assign(Object.assign(Object.assign({}, fieldState), (_proxyFormState.isValid && formOptions.resolver ? { isValid } : {})), { errors: _formState.errors, name });\r\n            _formState = Object.assign(Object.assign({}, _formState), updatedFormState);\r\n            _subjects.state.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        _validateCount[name]--;\r\n        if (!_validateCount[name]) {\r\n            _subjects.state.next({\r\n                isValidating: false,\r\n            });\r\n            _validateCount = {};\r\n        }\r\n    };\r\n    const setFieldValue = (name, value, options = {}, shouldRender) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                set(_formValues, name, getFieldValueAs(value, _f));\r\n                const fieldValue = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(value)\r\n                    ? ''\r\n                    : value;\r\n                if (isFileInput(_f.ref) && !isString(fieldValue)) {\r\n                    _f.ref.files = fieldValue;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = fieldValue.includes(selectRef.value)));\r\n                }\r\n                else if (_f.refs) {\r\n                    if (isCheckBoxInput(_f.ref)) {\r\n                        _f.refs.length > 1\r\n                            ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(fieldValue)\r\n                                ? !!fieldValue.find((data) => data === checkboxRef.value)\r\n                                : fieldValue === checkboxRef.value))\r\n                            : (_f.refs[0].checked = !!fieldValue);\r\n                    }\r\n                    else {\r\n                        _f.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));\r\n                    }\r\n                }\r\n                else {\r\n                    _f.ref.value = fieldValue;\r\n                }\r\n                if (shouldRender) {\r\n                    _subjects.control.next({\r\n                        values: getValues(),\r\n                        name,\r\n                    });\r\n                }\r\n                (options.shouldDirty || options.shouldTouch) &&\r\n                    updateTouchAndDirtyState(name, fieldValue, options.shouldTouch);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n        }\r\n    };\r\n    const updateTouchAndDirtyState = (name, inputValue, isCurrentTouched, shouldRender = true) => {\r\n        const state = {\r\n            name,\r\n        };\r\n        let isChanged = false;\r\n        if (_proxyFormState.isDirty) {\r\n            const previousIsDirty = _formState.isDirty;\r\n            _formState.isDirty = _getIsDirty();\r\n            state.isDirty = _formState.isDirty;\r\n            isChanged = previousIsDirty !== state.isDirty;\r\n        }\r\n        if (_proxyFormState.dirtyFields && !isCurrentTouched) {\r\n            const isPreviousFieldDirty = get(_formState.dirtyFields, name);\r\n            const isCurrentFieldDirty = !deepEqual(get(_defaultValues, name), inputValue);\r\n            isCurrentFieldDirty\r\n                ? set(_formState.dirtyFields, name, true)\r\n                : unset(_formState.dirtyFields, name);\r\n            state.dirtyFields = _formState.dirtyFields;\r\n            isChanged =\r\n                isChanged || isPreviousFieldDirty !== get(_formState.dirtyFields, name);\r\n        }\r\n        const isPreviousFieldTouched = get(_formState.touchedFields, name);\r\n        if (isCurrentTouched && !isPreviousFieldTouched) {\r\n            set(_formState.touchedFields, name, isCurrentTouched);\r\n            state.touchedFields = _formState.touchedFields;\r\n            isChanged =\r\n                isChanged ||\r\n                    (_proxyFormState.touchedFields &&\r\n                        isPreviousFieldTouched !== isCurrentTouched);\r\n        }\r\n        isChanged && shouldRender && _subjects.state.next(state);\r\n        return isChanged ? state : {};\r\n    };\r\n    const executeResolver = async (name) => {\r\n        return formOptions.resolver\r\n            ? await formOptions.resolver(Object.assign({}, _formValues), formOptions.context, getResolverOptions(name || _names.mount, _fields, formOptions.criteriaMode, formOptions.shouldUseNativeValidation))\r\n            : {};\r\n    };\r\n    const executeResolverValidation = async (names) => {\r\n        const { errors } = await executeResolver();\r\n        if (names) {\r\n            for (const name of names) {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(_formState.errors, name, error)\r\n                    : unset(_formState.errors, name);\r\n            }\r\n        }\r\n        else {\r\n            _formState.errors = errors;\r\n        }\r\n        return errors;\r\n    };\r\n    const validateForm = async (_fields, shouldCheckValid, context = {\r\n        valid: true,\r\n    }) => {\r\n        for (const name in _fields) {\r\n            const field = _fields[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const val = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, get(_formValues, _f.name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation);\r\n                    if (shouldCheckValid) {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                        }\r\n                        fieldError[_f.name]\r\n                            ? set(_formState.errors, _f.name, fieldError[_f.name])\r\n                            : unset(_formState.errors, _f.name);\r\n                    }\r\n                }\r\n                val && (await validateForm(val, shouldCheckValid, context));\r\n            }\r\n        }\r\n        return context.valid;\r\n    };\r\n    const handleChange = async ({ type, target, target: { value, name, type: inputType }, }) => {\r\n        let error;\r\n        let isValid;\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange } = getValidationModes(formOptions.reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !formOptions.resolver &&\r\n                !get(_formState.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(_formState.touchedFields, name), isSubmitted: _formState.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                set(_formValues, name, inputValue);\r\n            }\r\n            const fieldState = updateTouchAndDirtyState(name, inputValue, isBlurEvent, false);\r\n            const shouldRender = !isEmptyObject(fieldState) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    _subjects.watch.next({\r\n                        name,\r\n                        type,\r\n                    });\r\n                return (shouldRender &&\r\n                    _subjects.state.next(isWatched ? { name } : Object.assign(Object.assign({}, fieldState), { name })));\r\n            }\r\n            _validateCount[name] = _validateCount[name] ? +1 : 1;\r\n            _subjects.state.next({\r\n                isValidating: true,\r\n            });\r\n            if (formOptions.resolver) {\r\n                const { errors } = await executeResolver([name]);\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const valError = get(errors, parentNodeName, {});\r\n                    valError.type && valError.message && (error = valError);\r\n                    if (valError || get(_formState.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n            }\r\n            else {\r\n                error = (await validateField(field, get(_formValues, name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                _subjects.watch.next({\r\n                    name,\r\n                    type,\r\n                    values: getValues(),\r\n                });\r\n            shouldRenderBaseOnError(false, name, error, fieldState, isValid, isWatched);\r\n        }\r\n    };\r\n    const _updateValidAndInputValue = (name, ref, shouldSkipValueAs) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const fieldValue = get(_formValues, name);\r\n            const isValueUndefined = isUndefined(fieldValue);\r\n            const defaultValue = isValueUndefined\r\n                ? get(_defaultValues, name)\r\n                : fieldValue;\r\n            if (isUndefined(defaultValue) ||\r\n                (ref && ref.defaultChecked) ||\r\n                shouldSkipValueAs) {\r\n                set(_formValues, name, shouldSkipValueAs ? defaultValue : getFieldValue(field));\r\n            }\r\n            else {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        _isMounted && _proxyFormState.isValid && _updateValid();\r\n    };\r\n    const _getIsDirty = (name, data) => {\r\n        name && data && set(_formValues, name, data);\r\n        return !deepEqual(Object.assign({}, getValues()), _defaultValues);\r\n    };\r\n    const _updateValid = async () => {\r\n        const isValid = formOptions.resolver\r\n            ? isEmptyObject((await executeResolver()).errors)\r\n            : await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const setValues = (name, value, options) => Object.entries(value).forEach(([fieldKey, fieldValue]) => {\r\n        const fieldName = `${name}.${fieldKey}`;\r\n        const field = get(_fields, fieldName);\r\n        const isFieldArray = _names.array.has(name);\r\n        (isFieldArray || !isPrimitive(fieldValue) || (field && !field._f)) &&\r\n            !isDateObject(fieldValue)\r\n            ? setValues(fieldName, fieldValue, options)\r\n            : setFieldValue(fieldName, fieldValue, options, true);\r\n    });\r\n    const _getWatch = (fieldNames, defaultValue, isGlobal) => {\r\n        const fieldValues = Object.assign({}, (_isMounted\r\n            ? _formValues\r\n            : isUndefined(defaultValue)\r\n                ? _defaultValues\r\n                : isString(fieldNames)\r\n                    ? { [fieldNames]: defaultValue }\r\n                    : defaultValue));\r\n        if (!fieldNames) {\r\n            isGlobal && (_names.watchAll = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && _names.watch.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return Array.isArray(fieldNames)\r\n            ? result\r\n            : isObject(result[0])\r\n                ? Object.assign({}, result[0]) : Array.isArray(result[0])\r\n                ? [...result[0]]\r\n                : result[0];\r\n    };\r\n    const _updateValues = (defaultValues, name = '') => {\r\n        for (const key in defaultValues) {\r\n            const value = defaultValues[key];\r\n            const fieldName = name + (name ? '.' : '') + key;\r\n            const field = get(_fields, fieldName);\r\n            if (!field || !field._f) {\r\n                if (isObject(value) || Array.isArray(value)) {\r\n                    _updateValues(value, fieldName);\r\n                }\r\n                else if (!field) {\r\n                    set(_formValues, fieldName, value);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const _updateFieldArray = (keyName, name, method, args, updatedFieldArrayValuesWithKey = [], shouldSet = true, shouldSetFields = true) => {\r\n        let output;\r\n        const updatedFieldArrayValues = omitKey(updatedFieldArrayValuesWithKey, keyName);\r\n        _isInAction = true;\r\n        if (shouldSetFields && get(_fields, name)) {\r\n            output = method(get(_fields, name), args.argA, args.argB);\r\n            shouldSet && set(_fields, name, output);\r\n        }\r\n        output = method(get(_formValues, name), args.argA, args.argB);\r\n        shouldSet && set(_formValues, name, output);\r\n        if (Array.isArray(get(_formState.errors, name))) {\r\n            const output = method(get(_formState.errors, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.errors, name, output);\r\n            unsetEmptyArray(_formState.errors, name);\r\n        }\r\n        if (_proxyFormState.touchedFields && get(_formState.touchedFields, name)) {\r\n            const output = method(get(_formState.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.touchedFields, name, output);\r\n            unsetEmptyArray(_formState.touchedFields, name);\r\n        }\r\n        if (_proxyFormState.dirtyFields || _proxyFormState.isDirty) {\r\n            set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            updatedFieldArrayValues &&\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            unsetEmptyArray(_formState.dirtyFields, name);\r\n        }\r\n        _subjects.state.next({\r\n            isDirty: _getIsDirty(name, omitKey(updatedFieldArrayValues, keyName)),\r\n            dirtyFields: _formState.dirtyFields,\r\n            errors: _formState.errors,\r\n            isValid: _formState.isValid,\r\n        });\r\n    };\r\n    const _getFieldArrayValue = (name) => get(_isMounted ? _formValues : _defaultValues, name, []);\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(_fields, name);\r\n        const isFieldArray = _names.array.has(name);\r\n        set(_formValues, name, value);\r\n        if (isFieldArray) {\r\n            _subjects.array.next({\r\n                name,\r\n                values: _formValues,\r\n            });\r\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(value, get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n                _subjects.state.next({\r\n                    name,\r\n                    dirtyFields: _formState.dirtyFields,\r\n                    isDirty: _getIsDirty(name, value),\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            field && !field._f && !isNullOrUndefined(value)\r\n                ? setValues(name, value, options)\r\n                : setFieldValue(name, value, options, true);\r\n        }\r\n        isFieldWatched(name) && _subjects.state.next({});\r\n        _subjects.watch.next({\r\n            name,\r\n        });\r\n    };\r\n    const trigger = async (name, options = {}) => {\r\n        const fieldNames = convertToArrayPayload(name);\r\n        let isValid;\r\n        _subjects.state.next({\r\n            isValidating: true,\r\n        });\r\n        if (formOptions.resolver) {\r\n            const schemaResult = await executeResolverValidation(isUndefined(name) ? name : fieldNames);\r\n            isValid = name\r\n                ? fieldNames.every((name) => !get(schemaResult, name))\r\n                : isEmptyObject(schemaResult);\r\n        }\r\n        else {\r\n            if (name) {\r\n                isValid = (await Promise.all(fieldNames.map(async (fieldName) => {\r\n                    const field = get(_fields, fieldName);\r\n                    return await validateForm(field._f ? { [fieldName]: field } : field);\r\n                }))).every(Boolean);\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n                isValid = isEmptyObject(_formState.errors);\r\n            }\r\n        }\r\n        _subjects.state.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: _formState.errors, isValidating: false }));\r\n        if (options.shouldFocus && !isValid) {\r\n            focusFieldBy(_fields, (key) => get(_formState.errors, key), name ? fieldNames : _names.mount);\r\n        }\r\n        _proxyFormState.isValid && _updateValid();\r\n        return isValid;\r\n    };\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, _defaultValues), _formValues);\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName))\r\n            : (_formState.errors = {});\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;\r\n        set(_formState.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        _subjects.state.next({\r\n            name,\r\n            errors: _formState.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? _subjects.watch.subscribe({\r\n            next: (info) => fieldName(_getWatch(undefined, defaultValue), info),\r\n        })\r\n        : _getWatch(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name ? convertToArrayPayload(name) : _names.mount) {\r\n            _names.mount.delete(inputName);\r\n            _names.array.delete(inputName);\r\n            if (get(_fields, inputName)) {\r\n                if (!options.keepValue) {\r\n                    unset(_fields, inputName);\r\n                    unset(_formValues, inputName);\r\n                }\r\n                !options.keepError && unset(_formState.errors, inputName);\r\n                !options.keepDirty && unset(_formState.dirtyFields, inputName);\r\n                !options.keepTouched && unset(_formState.touchedFields, inputName);\r\n                !formOptions.shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(_defaultValues, inputName);\r\n            }\r\n        }\r\n        _subjects.watch.next({});\r\n        _subjects.state.next(Object.assign(Object.assign({}, _formState), (!options.keepDirty ? {} : { isDirty: _getIsDirty() })));\r\n        !options.keepIsValid && _updateValid();\r\n    };\r\n    const registerFieldRef = (name, fieldRef, options) => {\r\n        register(name, options);\r\n        let field = get(_fields, name);\r\n        const ref = isUndefined(fieldRef.value)\r\n            ? fieldRef.querySelectorAll\r\n                ? fieldRef.querySelectorAll('input,select,textarea')[0] ||\r\n                    fieldRef\r\n                : fieldRef\r\n            : fieldRef;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isRadioOrCheckbox &&\r\n                compact(field._f.refs || []).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(_fields, name, field);\r\n        _updateValidAndInputValue(name, ref);\r\n    };\r\n    const register = (name, options = {}) => {\r\n        const field = get(_fields, name);\r\n        set(_fields, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        if (options.value) {\r\n            set(_formValues, name, options.value);\r\n        }\r\n        if (!isUndefined(options.disabled) &&\r\n            field &&\r\n            field._f &&\r\n            field._f.ref.disabled !== options.disabled) {\r\n            set(_formValues, name, options.disabled ? undefined : field._f.ref.value);\r\n        }\r\n        _names.mount.add(name);\r\n        !field && _updateValidAndInputValue(name, undefined, true);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : Object.assign(Object.assign({ name }, (isUndefined(options.disabled)\r\n                ? {}\r\n                : { disabled: options.disabled })), { onChange: handleChange, onBlur: handleChange, ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(_fields, name, {});\r\n                        const _shouldUnregister = formOptions.shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                        }\r\n                        _shouldUnregister &&\r\n                            !(isNameInFieldArray(_names.array, name) && _isInAction) &&\r\n                            _names.unMount.add(name);\r\n                    }\r\n                } });\r\n    };\r\n    const handleSubmit = (onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = Object.assign({}, _formValues);\r\n        _subjects.state.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (formOptions.resolver) {\r\n                const { errors, values } = await executeResolver();\r\n                _formState.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n            }\r\n            if (isEmptyObject(_formState.errors) &&\r\n                Object.keys(_formState.errors).every((name) => get(fieldValues, name))) {\r\n                _subjects.state.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(_formState.errors, e));\r\n                formOptions.shouldFocusError &&\r\n                    focusFieldBy(_fields, (key) => get(_formState.errors, key), _names.mount);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            _formState.isSubmitted = true;\r\n            _subjects.state.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && hasNoPromiseError,\r\n                submitCount: _formState.submitCount + 1,\r\n                errors: _formState.errors,\r\n            });\r\n        }\r\n    };\r\n    const reset = (formValues, keepStateOptions = {}) => {\r\n        const updatedValues = formValues || _defaultValues;\r\n        const values = cloneObject(updatedValues);\r\n        _formValues = values;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of _names.mount) {\r\n                const field = get(_fields, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        if (!keepStateOptions.keepDefaultValues) {\r\n            _defaultValues = Object.assign({}, updatedValues);\r\n        }\r\n        if (!keepStateOptions.keepValues) {\r\n            _fields = {};\r\n            _subjects.control.next({\r\n                values: keepStateOptions.keepDefaultValues\r\n                    ? _defaultValues\r\n                    : Object.assign({}, updatedValues),\r\n            });\r\n            _subjects.watch.next({});\r\n            _subjects.array.next({\r\n                values,\r\n            });\r\n        }\r\n        _names = {\r\n            mount: new Set(),\r\n            unMount: new Set(),\r\n            array: new Set(),\r\n            watch: new Set(),\r\n            watchAll: false,\r\n            focus: '',\r\n        };\r\n        _subjects.state.next({\r\n            submitCount: keepStateOptions.keepSubmitCount\r\n                ? _formState.submitCount\r\n                : 0,\r\n            isDirty: keepStateOptions.keepDirty\r\n                ? _formState.isDirty\r\n                : keepStateOptions.keepDefaultValues\r\n                    ? deepEqual(formValues, _defaultValues)\r\n                    : false,\r\n            isSubmitted: keepStateOptions.keepIsSubmitted\r\n                ? _formState.isSubmitted\r\n                : false,\r\n            dirtyFields: keepStateOptions.keepDirty ? _formState.dirtyFields : {},\r\n            touchedFields: keepStateOptions.keepTouched\r\n                ? _formState.touchedFields\r\n                : {},\r\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n        _isMounted = !!keepStateOptions.keepIsValid;\r\n    };\r\n    const setFocus = (name) => get(_fields, name)._f.ref.focus();\r\n    const _removeFields = () => {\r\n        for (const name of _names.unMount) {\r\n            const field = get(_fields, name);\r\n            field &&\r\n                (field._f.refs ? field._f.refs.every(live) : live(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        _names.unMount = new Set();\r\n    };\r\n    return {\r\n        control: {\r\n            register,\r\n            unregister,\r\n            _getWatch,\r\n            _getIsDirty,\r\n            _updateValid,\r\n            _updateValues,\r\n            _removeFields,\r\n            _updateFieldArray,\r\n            _getFieldArrayValue,\r\n            _subjects,\r\n            _shouldUnregister: formOptions.shouldUnregister,\r\n            _fields,\r\n            _proxyFormState,\r\n            get _formValues() {\r\n                return _formValues;\r\n            },\r\n            set _formValues(value) {\r\n                _formValues = value;\r\n            },\r\n            get _isMounted() {\r\n                return _isMounted;\r\n            },\r\n            set _isMounted(value) {\r\n                _isMounted = value;\r\n            },\r\n            get _defaultValues() {\r\n                return _defaultValues;\r\n            },\r\n            set _defaultValues(value) {\r\n                _defaultValues = value;\r\n            },\r\n            get _names() {\r\n                return _names;\r\n            },\r\n            set _names(value) {\r\n                _names = value;\r\n            },\r\n            _isInAction: {\r\n                get val() {\r\n                    return _isInAction;\r\n                },\r\n                set val(value) {\r\n                    _isInAction = value;\r\n                },\r\n            },\r\n            _formState: {\r\n                get val() {\r\n                    return _formState;\r\n                },\r\n                set val(value) {\r\n                    _formState = value;\r\n                },\r\n            },\r\n            _updateProps: (options) => {\r\n                formOptions = Object.assign(Object.assign({}, defaultOptions), options);\r\n            },\r\n        },\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch,\r\n        setValue,\r\n        getValues,\r\n        reset,\r\n        clearErrors,\r\n        unregister,\r\n        setError,\r\n        setFocus,\r\n    };\r\n}\n\nfunction useForm(props = {}) {\r\n    const _formControl = React.useRef();\r\n    const [formState, updateFormState] = React.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    });\r\n    if (_formControl.current) {\r\n        _formControl.current.control._updateProps(props);\r\n    }\r\n    else {\r\n        _formControl.current = Object.assign(Object.assign({}, createFormControl(props)), { formState });\r\n    }\r\n    const control = _formControl.current.control;\r\n    React.useEffect(() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, control._proxyFormState, true)) {\r\n                    control._formState.val = Object.assign(Object.assign({}, control._formState.val), formState);\r\n                    updateFormState(Object.assign({}, control._formState.val));\r\n                }\r\n            },\r\n        });\r\n        return () => {\r\n            formStateSubscription.unsubscribe();\r\n        };\r\n    }, [control]);\r\n    React.useEffect(() => {\r\n        if (!control._isMounted) {\r\n            control._isMounted = true;\r\n            control._proxyFormState.isValid && control._updateValid();\r\n            !props.shouldUnregister && control._updateValues(control._defaultValues);\r\n        }\r\n        control._removeFields();\r\n    });\r\n    _formControl.current.formState = getProxyFormState(formState, control._proxyFormState);\r\n    return _formControl.current;\r\n}\n\nfunction useWatch(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, defaultValue, disabled, } = props || {};\r\n    const _name = React.useRef(name);\r\n    _name.current = name;\r\n    const [value, updateValue] = React.useState(isUndefined(defaultValue)\r\n        ? control._getWatch(name)\r\n        : defaultValue);\r\n    React.useEffect(() => {\r\n        const watchSubscription = control._subjects.watch.subscribe({\r\n            next: ({ name }) => {\r\n                (!_name.current ||\r\n                    !name ||\r\n                    convertToArrayPayload(_name.current).some((fieldName) => name &&\r\n                        fieldName &&\r\n                        (fieldName.startsWith(name) ||\r\n                            name.startsWith(fieldName)))) &&\r\n                    updateValue(control._getWatch(_name.current, defaultValue));\r\n            },\r\n        });\r\n        disabled && watchSubscription.unsubscribe();\r\n        return () => watchSubscription.unsubscribe();\r\n    }, [disabled, control, defaultValue]);\r\n    React.useEffect(() => {\r\n        control._removeFields();\r\n    });\r\n    return value;\r\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };\n//# sourceMappingURL=index.esm.js.map\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}"]}}