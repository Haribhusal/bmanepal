{"code":"(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[7],{NKCw:function(e,t,s){\"use strict\";s.d(t,\"a\",(function(){return M})),s.d(t,\"b\",(function(){return U})),s.d(t,\"c\",(function(){return g})),s.d(t,\"d\",(function(){return I})),s.d(t,\"e\",(function(){return Fe}));var r=s(\"q1tI\"),i=e=>\"checkbox\"===e.type,n=e=>e instanceof Date,a=e=>null==e;const o=e=>\"object\"===typeof e;var l=e=>!a(e)&&!Array.isArray(e)&&o(e)&&!n(e),u=e=>e.substring(0,e.search(/.\\d/))||e,c=(e,t)=>[...e].some((e=>u(t)===e)),d=e=>e.filter(Boolean),f=e=>void 0===e,g=(e,t,s)=>{if(l(e)&&t){const r=d(t.split(/[,[\\].]+?/)).reduce(((e,t)=>a(e)?e:e[t]),e);return f(r)||r===e?f(e[t])?s:e[t]:r}};const y=\"blur\",b=\"change\",m=\"onBlur\",h=\"onChange\",v=\"onSubmit\",p=\"onTouched\",_=\"all\",O=\"max\",V=\"min\",w=\"maxLength\",j=\"minLength\",F=\"pattern\",A=\"required\",S=\"validate\";var x=(e,t)=>{const s=Object.assign({},e);return delete s[t],s};const k=r.createContext(null);k.displayName=\"RHFContext\";const D=()=>r.useContext(k);var C=(e,t,s,r=!0)=>{function i(i){return()=>{if(i in e)return t[i]!==_&&(t[i]=!r||_),s&&(s[i]=!0),e[i]}}const n={};for(const a in e)Object.defineProperty(n,a,{get:i(a)});return n},E=e=>l(e)&&!Object.keys(e).length,B=(e,t,s)=>{const r=x(e,\"name\");return E(r)||Object.keys(r).length>=Object.keys(t).length||Object.keys(r).find((e=>t[e]===(!s||_)))},N=e=>Array.isArray(e)?e:[e];function T(e){const t=D(),{name:s,control:n=t.control,shouldUnregister:a}=e,[o,u]=r.useState(g(n._formValues,s,g(n._defaultValues,s,e.defaultValue))),d=function(e){const t=D(),{control:s=t.control,disabled:i,name:n}=e||{},a=r.useRef(n),[o,l]=r.useState(s._formState.val),u=r.useRef({isDirty:!1,dirtyFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1});return a.current=n,r.useEffect((()=>{const e=s._subjects.state.subscribe({next:e=>(!a.current||!e.name||N(a.current).includes(e.name))&&B(e,u.current)&&l(Object.assign(Object.assign({},s._formState.val),e))});return i&&e.unsubscribe(),()=>e.unsubscribe()}),[i,s]),C(o,s._proxyFormState,u.current,!1)}({control:n||t.control,name:s}),f=n.register(s,Object.assign(Object.assign({},e.rules),{value:o})),m=r.useCallback(((e,t)=>{const s=g(n._fields,e);s&&(s._f.mount=t)}),[n]);return r.useEffect((()=>{const e=n._subjects.control.subscribe({next:e=>(!e.name||s===e.name)&&u(g(e.values,s))});return m(s,!0),()=>{e.unsubscribe();const t=n._shouldUnregister||a;(c(n._names.array,s)?t&&!n._isInAction.val:t)?n.unregister(s):m(s,!1)}}),[s,n,a,m]),{field:{onChange:e=>{const t=(e=>l(e)&&e.target?i(e.target)?e.target.checked:e.target.value:e)(e);u(t),f.onChange({target:{value:t,name:s},type:b})},onBlur:()=>{f.onBlur({target:{name:s},type:y})},name:s,value:o,ref:e=>e&&f.ref({focus:()=>e.focus&&e.focus(),setCustomValidity:t=>e.setCustomValidity(t),reportValidity:()=>e.reportValidity()})},formState:d,fieldState:{invalid:!!g(d.errors,s),isDirty:!!g(d.dirtyFields,s),isTouched:!!g(d.touchedFields,s),error:g(d.errors,s)}}}const M=e=>e.render(T(e));var U=(e,t,s,r,i)=>t?Object.assign(Object.assign({},s[e]),{types:Object.assign(Object.assign({},s[e]&&s[e].types?s[e].types:{}),{[r]:i||!0})}):{},R=e=>/^\\w*$/.test(e),L=e=>d(e.replace(/[\"|']|\\]/g,\"\").split(/\\.|\\[/));function I(e,t,s){let r=-1;const i=R(t)?[t]:L(t),n=i.length,a=n-1;for(;++r<n;){const t=i[r];let n=s;if(r!==a){const s=e[t];n=l(s)||Array.isArray(s)?s:isNaN(+i[r+1])?{}:[]}e[t]=n,e=e[t]}return e}const q=(e,t,s)=>{for(const r of s||Object.keys(e)){const s=g(e,r);if(s){const e=s._f,r=x(s,\"_f\");if(e&&t(e.name)){if(e.ref.focus&&f(e.ref.focus()))break;if(e.refs){e.refs[0].focus();break}}else l(r)&&q(r,t)}}};function P(e){let t;const s=Array.isArray(e);if(e instanceof Date)t=new Date(e.getTime());else{if(!s&&!l(e))return e;t=s?[]:{};for(const s in e)t[s]=P(e[s])}return t}var H=e=>a(e)||!o(e);function $(e,t){if(H(e)||H(t)||n(e)||n(t))return e===t;const s=Object.keys(e),r=Object.keys(t);if(s.length!==r.length)return!1;for(const i of s){const s=e[i];if(!r.includes(i))return!1;if(\"ref\"!==i){const e=t[i];if((l(s)||Array.isArray(s))&&(l(e)||Array.isArray(e))?!$(s,e):s!==e)return!1}}return!0}var J=e=>({isOnSubmit:!e||e===v,isOnBlur:e===m,isOnChange:e===h,isOnAll:e===_,isOnTouch:e===p}),K=e=>\"file\"===e.type,W=e=>\"function\"===typeof e,z=e=>e instanceof HTMLElement,G=e=>\"select-multiple\"===e.type,Q=e=>\"radio\"===e.type,X=e=>\"string\"===typeof e,Y=\"undefined\"!==typeof window&&\"undefined\"!==typeof window.HTMLElement&&\"undefined\"!==typeof document,Z=e=>!z(e)||!document.contains(e),ee=(e,t)=>e.map(((e={})=>x(e,t)));class te{constructor(){this.tearDowns=[]}add(e){this.tearDowns.push(e)}unsubscribe(){for(const e of this.tearDowns)e();this.tearDowns=[]}}class se{constructor(e,t){this.observer=e,this.closed=!1,t.add((()=>this.closed=!0))}next(e){this.closed||this.observer.next(e)}}class re{constructor(){this.observers=[]}next(e){for(const t of this.observers)t.next(e)}subscribe(e){const t=new te,s=new se(e,t);return this.observers.push(s),t}unsubscribe(){this.observers=[]}}var ie=e=>\"boolean\"===typeof e;function ne(e,t){const s=R(t)?[t]:L(t),r=1==s.length?e:function(e,t){const s=t.slice(0,-1).length;let r=0;for(;r<s;)e=f(e)?r++:e[t[r++]];return e}(e,s),i=s[s.length-1];let n;r&&delete r[i];for(let a=0;a<s.slice(0,-1).length;a++){let t,r=-1;const i=s.slice(0,-(a+1)),o=i.length-1;for(a>0&&(n=e);++r<i.length;){const s=i[r];t=t?t[s]:e[s],o===r&&(l(t)&&E(t)||Array.isArray(t)&&!t.filter((e=>l(e)&&!E(e)||ie(e))).length)&&(n?delete n[s]:delete e[s]),n=t}}return e}const ae={value:!1,isValid:!1},oe={value:!0,isValid:!0};var le=e=>{if(Array.isArray(e)){if(e.length>1){const t=e.filter((e=>e&&e.checked&&!e.disabled)).map((e=>e.value));return{value:t,isValid:!!t.length}}return e[0].checked&&!e[0].disabled?e[0].attributes&&!f(e[0].attributes.value)?f(e[0].value)||\"\"===e[0].value?oe:{value:e[0].value,isValid:!0}:oe:ae}return ae},ue=(e,{valueAsNumber:t,valueAsDate:s,setValueAs:r})=>f(e)?e:t?\"\"===e?NaN:+e:s?new Date(e):r?r(e):e;const ce={isValid:!1,value:null};var de=e=>Array.isArray(e)?e.reduce(((e,t)=>t&&t.checked&&!t.disabled?{isValid:!0,value:t.value}:e),ce):ce;function fe(e){if(e&&e._f){const s=e._f.ref;if(e._f.refs?e._f.refs.every((e=>e.disabled)):s.disabled)return;return K(s)?s.files:Q(s)?de(e._f.refs).value:G(s)?(t=s.options,[...t].filter((({selected:e})=>e)).map((({value:e})=>e))):i(s)?le(e._f.refs).value:ue(f(s.value)?e._f.ref.value:s.value,e._f)}var t}function ge(e,t){if(H(e)||H(t))return t;for(const r in t){const i=e[r],n=t[r];try{e[r]=l(i)&&l(n)||Array.isArray(i)&&Array.isArray(n)?ge(i,n):n}catch(s){}}return e}function ye(e,t,s,r,i){let n=-1;for(;++n<e.length;){for(const r in e[n])Array.isArray(e[n][r])?(!s[n]&&(s[n]={}),s[n][r]=[],ye(e[n][r],g(t[n]||{},r,[]),s[n][r],s[n],r)):!a(t)&&$(g(t[n]||{},r),e[n][r])?I(s[n]||{},r):s[n]=Object.assign(Object.assign({},s[n]),{[r]:!0});r&&!s.length&&delete r[i]}return s}var be=(e,t,s)=>ge(ye(e,t,s.slice(0,e.length)),ye(t,e,s.slice(0,e.length))),me=(e,t)=>!d(g(e,t,[])).length&&ne(e,t),he=e=>X(e)||r.isValidElement(e),ve=e=>e instanceof RegExp;function pe(e,t,s=\"validate\"){if(he(e)||Array.isArray(e)&&e.every(he)||ie(e)&&!e)return{type:s,message:he(e)?e:\"\",ref:t}}var _e=e=>l(e)&&!ve(e)?e:{value:e,message:\"\"},Oe=async(e,t,s,r)=>{const{ref:n,refs:o,required:u,maxLength:c,minLength:d,min:f,max:g,pattern:y,validate:b,name:m,valueAsNumber:h,mount:v,disabled:p}=e._f;if(!v||p)return{};const _=o?o[0]:n,x=e=>{r&&_.reportValidity&&(_.setCustomValidity(ie(e)?\"\":e||\" \"),_.reportValidity())},k={},D=Q(n),C=i(n),B=D||C,N=(h||K(n))&&!n.value||\"\"===t||Array.isArray(t)&&!t.length,T=U.bind(null,m,s,k),M=(e,t,s,r=w,i=j)=>{const a=e?t:s;k[m]=Object.assign({type:e?r:i,message:a,ref:n},T(e?r:i,a))};if(u&&(!B&&(N||a(t))||ie(t)&&!t||C&&!le(o).isValid||D&&!de(o).isValid)){const{value:e,message:t}=he(u)?{value:!!u,message:u}:_e(u);if(e&&(k[m]=Object.assign({type:A,message:t,ref:_},T(A,t)),!s))return x(t),k}if(!N&&(!a(f)||!a(g))){let e,r;const i=_e(g),o=_e(f);if(isNaN(t)){const s=n.valueAsDate||new Date(t);X(i.value)&&(e=s>new Date(i.value)),X(o.value)&&(r=s<new Date(o.value))}else{const s=n.valueAsNumber||parseFloat(t);a(i.value)||(e=s>i.value),a(o.value)||(r=s<o.value)}if((e||r)&&(M(!!e,i.message,o.message,O,V),!s))return x(k[m].message),k}if((c||d)&&!N&&X(t)){const e=_e(c),r=_e(d),i=!a(e.value)&&t.length>e.value,n=!a(r.value)&&t.length<r.value;if((i||n)&&(M(i,e.message,r.message),!s))return x(k[m].message),k}if(y&&!N&&X(t)){const{value:e,message:r}=_e(y);if(ve(e)&&!t.match(e)&&(k[m]=Object.assign({type:F,message:r,ref:n},T(F,r)),!s))return x(r),k}if(b)if(W(b)){const e=pe(await b(t),_);if(e&&(k[m]=Object.assign(Object.assign({},e),T(S,e.message)),!s))return x(e.message),k}else if(l(b)){let e={};for(const r in b){if(!E(e)&&!s)break;const i=pe(await b[r](t),_,r);i&&(e=Object.assign(Object.assign({},i),T(r,i.message)),x(i.message),s&&(k[m]=e))}if(!E(e)&&(k[m]=Object.assign({ref:_},e),!s))return k}return x(!0),k};const Ve={mode:v,reValidateMode:h,shouldFocusError:!0},we=\"undefined\"===typeof window;function je(e={}){let t,s=Object.assign(Object.assign({},Ve),e),r={isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}},o={},b={},m=s.defaultValues||{},h=!1,v=!1,p=0,O={mount:new Set,unMount:new Set,array:new Set,watch:new Set},V={};const w={isDirty:!1,dirtyFields:!1,touchedFields:!1,isValidating:!1,isValid:!1,errors:!1},j={watch:new re,control:new re,array:new re,state:new re},F=J(s.mode),A=s.criteriaMode===_,S=e=>O.watchAll||O.watch.has(e)||O.watch.has((e.match(/\\w+/)||[])[0]),k=(e,t)=>{I(r.errors,e,t),j.state.next({errors:r.errors})},D=async(i,n,a,l,u,c)=>{const d=g(r.errors,n),f=!(!w.isValid||!(s.resolver?u:(async()=>{const e=await M(o,!0);e!==r.isValid&&(r.isValid=e,j.state.next({isValid:e}))})()));var y,b;if(e.delayError&&a?(t=t||(y=k,b=e.delayError,(...e)=>{clearTimeout(p),p=window.setTimeout((()=>y(...e)),b)}),t(n,a)):(clearTimeout(p),a?I(r.errors,n,a):ne(r.errors,n)),(c||(a?!$(d,a):d)||!E(l)||r.isValid!==f)&&!i){const e=Object.assign(Object.assign(Object.assign({},l),w.isValid&&s.resolver?{isValid:f}:{}),{errors:r.errors,name:n});r=Object.assign(Object.assign({},r),e),j.state.next(c?{name:n}:e)}V[n]--,V[n]||(j.state.next({isValidating:!1}),V={})},C=(e,t,s={},r)=>{const n=g(o,e);if(n){const o=n._f;if(o){I(b,e,ue(t,o));const n=Y&&z(o.ref)&&a(t)?\"\":t;K(o.ref)&&!X(n)?o.ref.files=n:G(o.ref)?[...o.ref.options].forEach((e=>e.selected=n.includes(e.value))):o.refs?i(o.ref)?o.refs.length>1?o.refs.forEach((e=>e.checked=Array.isArray(n)?!!n.find((t=>t===e.value)):n===e.value)):o.refs[0].checked=!!n:o.refs.forEach((e=>e.checked=e.value===n)):o.ref.value=n,r&&j.control.next({values:le(),name:e}),(s.shouldDirty||s.shouldTouch)&&B(e,n,s.shouldTouch),s.shouldValidate&&oe(e)}}},B=(e,t,s,i=!0)=>{const n={name:e};let a=!1;if(w.isDirty){const e=r.isDirty;r.isDirty=L(),n.isDirty=r.isDirty,a=e!==n.isDirty}if(w.dirtyFields&&!s){const s=g(r.dirtyFields,e);!$(g(m,e),t)?I(r.dirtyFields,e,!0):ne(r.dirtyFields,e),n.dirtyFields=r.dirtyFields,a=a||s!==g(r.dirtyFields,e)}const o=g(r.touchedFields,e);return s&&!o&&(I(r.touchedFields,e,s),n.touchedFields=r.touchedFields,a=a||w.touchedFields&&o!==s),a&&i&&j.state.next(n),a?n:{}},T=async e=>s.resolver?await s.resolver(Object.assign({},b),s.context,((e,t,s,r)=>{const i={};for(const n of e){const e=g(t,n);e&&I(i,n,e._f)}return{criteriaMode:s,names:[...e],fields:i,shouldUseNativeValidation:r}})(e||O.mount,o,s.criteriaMode,s.shouldUseNativeValidation)):{},M=async(e,t,i={valid:!0})=>{for(const n in e){const a=e[n];if(a){const e=a._f,n=x(a,\"_f\");if(e){const n=await Oe(a,g(b,e.name),A,s.shouldUseNativeValidation);if(t){if(n[e.name]){i.valid=!1;break}}else n[e.name]&&(i.valid=!1),n[e.name]?I(r.errors,e.name,n[e.name]):ne(r.errors,e.name)}n&&await M(n,t,i)}}return i.valid},U=async({type:e,target:t,target:{value:n,name:a,type:l}})=>{let c,d;const m=g(o,a);if(m){let o=l?fe(m):void 0;o=f(o)?n:o;const v=e===y,{isOnBlur:p,isOnChange:_}=J(s.reValidateMode),O=(h=m._f,!(m._f.mount&&h&&(h.required||h.min||h.max||h.maxLength||h.minLength||h.pattern||h.validate))&&!s.resolver&&!g(r.errors,a)||(({isOnBlur:e,isOnChange:t,isOnTouch:s,isTouched:r,isReValidateOnBlur:i,isReValidateOnChange:n,isBlurEvent:a,isSubmitted:o,isOnAll:l})=>!l&&(!o&&s?!(r||a):(o?i:e)?!a:!(o?n:t)||a))(Object.assign({isBlurEvent:v,isTouched:!!g(r.touchedFields,a),isSubmitted:r.isSubmitted,isReValidateOnBlur:p,isReValidateOnChange:_},F))),w=!v&&S(a);f(o)||I(b,a,o);const x=B(a,o,v,!1),k=!E(x)||w;if(O)return!v&&j.watch.next({name:a,type:e}),k&&j.state.next(w?{name:a}:Object.assign(Object.assign({},x),{name:a}));if(V[a]=(V[a],1),j.state.next({isValidating:!0}),s.resolver){const{errors:e}=await T([a]);if(c=g(e,a),i(t)&&!c){const t=u(a),s=g(e,t,{});s.type&&s.message&&(c=s),(s||g(r.errors,t))&&(a=t)}d=E(e)}else c=(await Oe(m,g(b,a),A,s.shouldUseNativeValidation))[a];!v&&j.watch.next({name:a,type:e,values:le()}),D(!1,a,c,x,d,w)}var h},R=(e,t,s)=>{const r=g(o,e);if(r){const i=g(b,e),n=f(i)?g(m,e):i;f(n)||t&&t.defaultChecked||s?I(b,e,s?n:fe(r)):C(e,n)}v&&w.isValid&&te()},L=(e,t)=>(e&&t&&I(b,e,t),!$(Object.assign({},le()),m)),te=async()=>{const e=s.resolver?E((await T()).errors):await M(o,!0);e!==r.isValid&&(r.isValid=e,j.state.next({isValid:e}))},se=(e,t,s)=>Object.entries(t).forEach((([t,r])=>{const i=`${e}.${t}`,a=g(o,i);!O.array.has(e)&&H(r)&&(!a||a._f)||n(r)?C(i,r,s,!0):se(i,r,s)})),ie=(e,t,s)=>{const r=Object.assign({},v?b:f(t)?m:X(e)?{[e]:t}:t);if(!e)return s&&(O.watchAll=!0),r;const i=[];for(const n of N(e))s&&O.watch.add(n),i.push(g(r,n));return Array.isArray(e)?i:l(i[0])?Object.assign({},i[0]):Array.isArray(i[0])?[...i[0]]:i[0]},ae=(e,t=\"\")=>{for(const s in e){const r=e[s],i=t+(t?\".\":\"\")+s,n=g(o,i);n&&n._f||(l(r)||Array.isArray(r)?ae(r,i):n||I(b,i,r))}},oe=async(e,t={})=>{const i=N(e);let n;if(j.state.next({isValidating:!0}),s.resolver){const t=await(async e=>{const{errors:t}=await T();if(e)for(const s of e){const e=g(t,s);e?I(r.errors,s,e):ne(r.errors,s)}else r.errors=t;return t})(f(e)?e:i);n=e?i.every((e=>!g(t,e))):E(t)}else e?n=(await Promise.all(i.map((async e=>{const t=g(o,e);return await M(t._f?{[e]:t}:t)})))).every(Boolean):(await M(o),n=E(r.errors));return j.state.next(Object.assign(Object.assign({},X(e)?{name:e}:{}),{errors:r.errors,isValidating:!1})),t.shouldFocus&&!n&&q(o,(e=>g(r.errors,e)),e?i:O.mount),w.isValid&&te(),n},le=e=>{const t=Object.assign(Object.assign({},m),b);return f(e)?t:X(e)?g(t,e):e.map((e=>g(t,e)))},ce=(e,t={})=>{for(const i of e?N(e):O.mount)O.mount.delete(i),O.array.delete(i),g(o,i)&&(t.keepValue||(ne(o,i),ne(b,i)),!t.keepError&&ne(r.errors,i),!t.keepDirty&&ne(r.dirtyFields,i),!t.keepTouched&&ne(r.touchedFields,i),!s.shouldUnregister&&!t.keepDefaultValue&&ne(m,i));j.watch.next({}),j.state.next(Object.assign(Object.assign({},r),t.keepDirty?{isDirty:L()}:{})),!t.keepIsValid&&te()},de=(e,t,s)=>{ge(e,s);let r=g(o,e);const n=f(t.value)&&t.querySelectorAll&&t.querySelectorAll(\"input,select,textarea\")[0]||t,a=(e=>Q(e)||i(e))(n);n===r._f.ref||a&&d(r._f.refs||[]).find((e=>e===n))||(r={_f:a?Object.assign(Object.assign({},r._f),{refs:[...d(r._f.refs||[]).filter((e=>z(e)&&document.contains(e))),n],ref:{type:n.type,name:e}}):Object.assign(Object.assign({},r._f),{ref:n})},I(o,e,r),R(e,n))},ge=(e,t={})=>{const r=g(o,e);return I(o,e,{_f:Object.assign(Object.assign(Object.assign({},r&&r._f?r._f:{ref:{name:e}}),{name:e,mount:!0}),t)}),t.value&&I(b,e,t.value),!f(t.disabled)&&r&&r._f&&r._f.ref.disabled!==t.disabled&&I(b,e,t.disabled?void 0:r._f.ref.value),O.mount.add(e),!r&&R(e,void 0,!0),we?{name:e}:Object.assign(Object.assign({name:e},f(t.disabled)?{}:{disabled:t.disabled}),{onChange:U,onBlur:U,ref:r=>{if(r)de(e,r,t);else{const r=g(o,e,{}),i=s.shouldUnregister||t.shouldUnregister;r._f&&(r._f.mount=!1),i&&(!c(O.array,e)||!h)&&O.unMount.add(e)}}})};return{control:{register:ge,unregister:ce,_getWatch:ie,_getIsDirty:L,_updateValid:te,_updateValues:ae,_removeFields:()=>{for(const e of O.unMount){const t=g(o,e);t&&(t._f.refs?t._f.refs.every(Z):Z(t._f.ref))&&ce(e)}O.unMount=new Set},_updateFieldArray:(e,t,s,i,n=[],a=!0,l=!0)=>{let u;const c=ee(n,e);if(h=!0,l&&g(o,t)&&(u=s(g(o,t),i.argA,i.argB),a&&I(o,t,u)),u=s(g(b,t),i.argA,i.argB),a&&I(b,t,u),Array.isArray(g(r.errors,t))){const e=s(g(r.errors,t),i.argA,i.argB);a&&I(r.errors,t,e),me(r.errors,t)}if(w.touchedFields&&g(r.touchedFields,t)){const e=s(g(r.touchedFields,t),i.argA,i.argB);a&&I(r.touchedFields,t,e),me(r.touchedFields,t)}(w.dirtyFields||w.isDirty)&&(I(r.dirtyFields,t,be(ee(c,e),g(m,t,[]),g(r.dirtyFields,t,[]))),c&&I(r.dirtyFields,t,be(ee(c,e),g(m,t,[]),g(r.dirtyFields,t,[]))),me(r.dirtyFields,t)),j.state.next({isDirty:L(t,ee(c,e)),dirtyFields:r.dirtyFields,errors:r.errors,isValid:r.isValid})},_getFieldArrayValue:e=>g(v?b:m,e,[]),_subjects:j,_shouldUnregister:s.shouldUnregister,_fields:o,_proxyFormState:w,get _formValues(){return b},set _formValues(e){b=e},get _isMounted(){return v},set _isMounted(e){v=e},get _defaultValues(){return m},set _defaultValues(e){m=e},get _names(){return O},set _names(e){O=e},_isInAction:{get val(){return h},set val(e){h=e}},_formState:{get val(){return r},set val(e){r=e}},_updateProps:e=>{s=Object.assign(Object.assign({},Ve),e)}},trigger:oe,register:ge,handleSubmit:(e,t)=>async i=>{i&&(i.preventDefault&&i.preventDefault(),i.persist&&i.persist());let n=!0,a=Object.assign({},b);j.state.next({isSubmitting:!0});try{if(s.resolver){const{errors:e,values:t}=await T();r.errors=e,a=t}else await M(o);E(r.errors)&&Object.keys(r.errors).every((e=>g(a,e)))?(j.state.next({errors:{},isSubmitting:!0}),await e(a,i)):(t&&await t(r.errors,i),s.shouldFocusError&&q(o,(e=>g(r.errors,e)),O.mount))}catch(l){throw n=!1,l}finally{r.isSubmitted=!0,j.state.next({isSubmitted:!0,isSubmitting:!1,isSubmitSuccessful:E(r.errors)&&n,submitCount:r.submitCount+1,errors:r.errors})}},watch:(e,t)=>W(e)?j.watch.subscribe({next:s=>e(ie(void 0,t),s)}):ie(e,t,!0),setValue:(e,t,s={})=>{const i=g(o,e),n=O.array.has(e);I(b,e,t),n?(j.array.next({name:e,values:b}),(w.isDirty||w.dirtyFields)&&s.shouldDirty&&(I(r.dirtyFields,e,be(t,g(m,e,[]),g(r.dirtyFields,e,[]))),j.state.next({name:e,dirtyFields:r.dirtyFields,isDirty:L(e,t)}))):!i||i._f||a(t)?C(e,t,s,!0):se(e,t,s),S(e)&&j.state.next({}),j.watch.next({name:e})},getValues:le,reset:(e,t={})=>{const s=e||m,i=P(s);if(b=i,Y&&!t.keepValues)for(const r of O.mount){const e=g(o,r);if(e&&e._f){const t=Array.isArray(e._f.refs)?e._f.refs[0]:e._f.ref;try{z(t)&&t.closest(\"form\").reset();break}catch(n){}}}t.keepDefaultValues||(m=Object.assign({},s)),t.keepValues||(o={},j.control.next({values:t.keepDefaultValues?m:Object.assign({},s)}),j.watch.next({}),j.array.next({values:i})),O={mount:new Set,unMount:new Set,array:new Set,watch:new Set,watchAll:!1,focus:\"\"},j.state.next({submitCount:t.keepSubmitCount?r.submitCount:0,isDirty:t.keepDirty?r.isDirty:!!t.keepDefaultValues&&$(e,m),isSubmitted:!!t.keepIsSubmitted&&r.isSubmitted,dirtyFields:t.keepDirty?r.dirtyFields:{},touchedFields:t.keepTouched?r.touchedFields:{},errors:t.keepErrors?r.errors:{},isSubmitting:!1,isSubmitSuccessful:!1}),v=!!t.keepIsValid},clearErrors:e=>{e?N(e).forEach((e=>ne(r.errors,e))):r.errors={},j.state.next({errors:r.errors})},unregister:ce,setError:(e,t,s)=>{const i=(g(o,e,{_f:{}})._f||{}).ref;I(r.errors,e,Object.assign(Object.assign({},t),{ref:i})),j.state.next({name:e,errors:r.errors,isValid:!1}),s&&s.shouldFocus&&i&&i.focus&&i.focus()},setFocus:e=>g(o,e)._f.ref.focus()}}function Fe(e={}){const t=r.useRef(),[s,i]=r.useState({isDirty:!1,isValidating:!1,dirtyFields:{},isSubmitted:!1,submitCount:0,touchedFields:{},isSubmitting:!1,isSubmitSuccessful:!1,isValid:!1,errors:{}});t.current?t.current.control._updateProps(e):t.current=Object.assign(Object.assign({},je(e)),{formState:s});const n=t.current.control;return r.useEffect((()=>{const e=n._subjects.state.subscribe({next(e){B(e,n._proxyFormState,!0)&&(n._formState.val=Object.assign(Object.assign({},n._formState.val),e),i(Object.assign({},n._formState.val)))}});return()=>{e.unsubscribe()}}),[n]),r.useEffect((()=>{n._isMounted||(n._isMounted=!0,n._proxyFormState.isValid&&n._updateValid(),!e.shouldUnregister&&n._updateValues(n._defaultValues)),n._removeFields()})),t.current.formState=C(s,n._proxyFormState),t.current}},cpVT:function(e,t,s){\"use strict\";function r(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}s.d(t,\"a\",(function(){return r}))}}]);","map":{"version":3,"sources":["static/chunks/e80ab424dbecc405e68f137226e5462669a09f3a.fd136118b1b05738054b.js"],"names":["window","push","NKCw","module","__webpack_exports__","__webpack_require__","d","Controller","appendErrors","get","set","useForm","react__WEBPACK_IMPORTED_MODULE_0__","isCheckBoxInput","element","type","isDateObject","data","Date","isNullOrUndefined","value","isObjectType","isObject","Array","isArray","getNodeParentName","name","substring","search","isNameInFieldArray","names","some","current","compact","filter","Boolean","isUndefined","val","undefined","obj","path","defaultValue","result","split","reduce","key","EVENTS","VALIDATION_MODE","INPUT_VALIDATION_RULES","omit","source","copy","Object","assign","FormContext","displayName","useFormContext","getProxyFormState","formState","_proxyFormState","localProxyFormState","isRoot","createGetter","prop","defineProperty","isEmptyObject","keys","length","shouldRenderFormState","formStateData","find","convertToArrayPayload","useController","props","methods","control","shouldUnregister","setInputStateValue","_formValues","_defaultValues","disabled","nameRef","updateFormState","_formState","_localProxyFormState","isDirty","dirtyFields","touchedFields","isValidating","isValid","errors","formStateSubscription","_subjects","state","subscribe","next","includes","unsubscribe","useFormState","registerProps","register","rules","updateMounted","field","_fields","_f","mount","controllerSubscription","values","_shouldUnregisterField","_shouldUnregister","_names","array","_isInAction","unregister","onChange","event","target","checked","getControllerValue","onBlur","ref","elm","focus","setCustomValidity","message","reportValidity","fieldState","invalid","isTouched","error","render","validateAllFieldCriteria","types","[object Object]","isKey","test","stringToPath","input","replace","object","index","tempPath","lastIndex","newValue","objValue","isNaN","focusFieldBy","fields","callback","fieldsNames","refs","cloneObject","getTime","isPrimitive","deepEqual","object1","object2","keys1","keys2","val1","val2","getValidationModes","mode","isOnSubmit","isOnBlur","isOnChange","isOnAll","isOnTouch","isFileInput","isFunction","isHTMLElement","HTMLElement","isMultipleSelect","isRadioInput","isString","isWeb","document","live","contains","omitKey","keyName","map","Subscription","this","tearDowns","tearDown","teardown","Subscriber","observer","subscription","closed","add","Subject","observers","subscriber","isBoolean","unset","updatePath","childObject","slice","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","defaultResult","validResult","getCheckboxValue","options","option","attributes","getFieldValueAs","valueAsNumber","valueAsDate","setValueAs","NaN","defaultReturn","getRadioValue","previous","getFieldValue","every","files","selected","deepMerge","targetValue","sourceValue","_a","setDirtyFields","defaultValues","parentNode","parentName","setFieldArrayDirtyFields","unsetEmptyArray","isMessage","isRegex","RegExp","getValidateError","getValueAndMessage","validationData","validateField","async","inputValue","shouldUseNativeValidation","required","maxLength","minLength","min","max","pattern","validate","inputRef","setCustomValidty","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","exceedMin","maxOutput","minOutput","valueDate","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","match","validateError","validationResult","defaultOptions","reValidateMode","shouldFocusError","isWindowUndefined","createFormControl","_delayCallback","formOptions","isSubmitted","submitCount","isSubmitting","isSubmitSuccessful","_isMounted","_timer","Set","unMount","watch","_validateCount","validationMode","isValidateAllFieldCriteria","criteriaMode","isFieldWatched","watchAll","has","updateErrorState","shouldRenderBaseOnError","shouldSkipRender","isValidFromResolver","isWatched","previousError","resolver","validateForm","shouldRenderBaseOnValid","wait","delayError","args","clearTimeout","setTimeout","updatedFormState","setFieldValue","shouldRender","fieldValue","forEach","selectRef","checkboxRef","radioRef","getValues","shouldDirty","shouldTouch","updateTouchAndDirtyState","shouldValidate","trigger","isCurrentTouched","isChanged","previousIsDirty","_getIsDirty","isPreviousFieldDirty","isPreviousFieldTouched","executeResolver","context","_fieldss","getResolverOptions","shouldCheckValid","valid","fieldError","handleChange","inputType","isBlurEvent","isReValidateOnBlur","isReValidateOnChange","shouldSkipValidation","skipValidation","parentNodeName","valError","_updateValidAndInputValue","shouldSkipValueAs","defaultChecked","_updateValid","setValues","entries","fieldKey","fieldName","_getWatch","fieldNames","isGlobal","fieldValues","_updateValues","schemaResult","executeResolverValidation","Promise","all","shouldFocus","inputName","delete","keepValue","keepError","keepDirty","keepTouched","keepDefaultValue","keepIsValid","registerFieldRef","fieldRef","querySelectorAll","isRadioOrCheckboxFunction","_removeFields","_updateFieldArray","method","updatedFieldArrayValuesWithKey","shouldSet","shouldSetFields","output","updatedFieldArrayValues","argA","argB","_getFieldArrayValue","_updateProps","handleSubmit","onValid","onInvalid","e","preventDefault","persist","hasNoPromiseError","err","info","setValue","isFieldArray","reset","formValues","keepStateOptions","updatedValues","keepValues","closest","keepDefaultValues","keepSubmitCount","keepIsSubmitted","keepErrors","clearErrors","setError","setFocus","_formControl","cpVT","_defineProperty","enumerable","configurable","writable"],"mappings":"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"},"name":"static/chunks/e80ab424dbecc405e68f137226e5462669a09f3a.fd136118b1b05738054b.js","input":"(window[\"webpackJsonp_N_E\"] = window[\"webpackJsonp_N_E\"] || []).push([[7],{\n\n/***/ \"NKCw\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Controller; });\n/* unused harmony export FormProvider */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return appendErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d\", function() { return set; });\n/* unused harmony export useController */\n/* unused harmony export useFieldArray */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"e\", function() { return useForm; });\n/* unused harmony export useFormContext */\n/* unused harmony export useFormState */\n/* unused harmony export useWatch */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"q1tI\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isDateObject = (data) => data instanceof Date;\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !isDateObject(value);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"](null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"](FormContext);\r\nconst FormProvider = (props) => (react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (formState, _proxyFormState, localProxyFormState, isRoot = true) => {\r\n    function createGetter(prop) {\r\n        return () => {\r\n            if (prop in formState) {\r\n                if (_proxyFormState[prop] !== VALIDATION_MODE.all) {\r\n                    _proxyFormState[prop] = !isRoot || VALIDATION_MODE.all;\r\n                }\r\n                localProxyFormState && (localProxyFormState[prop] = true);\r\n                return formState[prop];\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n    const result = {};\r\n    for (const key in formState) {\r\n        Object.defineProperty(result, key, {\r\n            get: createGetter(key),\r\n        });\r\n    }\r\n    return result;\r\n};\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, _proxyFormState, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||\r\n        Object.keys(formState).find((key) => _proxyFormState[key] ===\r\n            (!isRoot || VALIDATION_MODE.all)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, disabled, name } = props || {};\r\n    const nameRef = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](name);\r\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](control._formState.val);\r\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    nameRef.current = name;\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, _localProxyFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, control._formState.val), formState)),\r\n        });\r\n        disabled && formStateSubscription.unsubscribe();\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, [disabled, control]);\r\n    return getProxyFormState(formState, control._proxyFormState, _localProxyFormState.current, false);\r\n}\n\nfunction useController(props) {\r\n    const methods = useFormContext();\r\n    const { name, control = methods.control, shouldUnregister } = props;\r\n    const [value, setInputStateValue] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)));\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    const registerProps = control.register(name, Object.assign(Object.assign({}, props.rules), { value }));\r\n    const updateMounted = react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"]((name, value) => {\r\n        const field = get(control._fields, name);\r\n        if (field) {\r\n            field._f.mount = value;\r\n        }\r\n    }, [control]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const controllerSubscription = control._subjects.control.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        updateMounted(name, true);\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const _shouldUnregisterField = control._shouldUnregister || shouldUnregister;\r\n            if (isNameInFieldArray(control._names.array, name)\r\n                ? _shouldUnregisterField && !control._isInAction.val\r\n                : _shouldUnregisterField) {\r\n                control.unregister(name);\r\n            }\r\n            else {\r\n                updateMounted(name, false);\r\n            }\r\n        };\r\n    }, [name, control, shouldUnregister, updateMounted]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                registerProps.onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                registerProps.onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm &&\r\n                registerProps.ref({\r\n                    focus: () => elm.focus && elm.focus(),\r\n                    setCustomValidity: (message) => elm.setCustomValidity(message),\r\n                    reportValidity: () => elm.reportValidity(),\r\n                }),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nvar getFocusFieldName = (name, index, options) => options && !options.shouldFocus\r\n    ? options.focusName || `${name}.${options.focusIndex}.`\r\n    : `${name}.${index}.`;\n\nvar mapCurrentIds = (values, _fieldIds, keyName) => values.map((value, index) => {\r\n    const output = _fieldIds.current[index];\r\n    return Object.assign(Object.assign({}, value), (output ? { [keyName]: output[keyName] } : {}));\r\n});\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign(Object.assign({}, (value[keyName] ? {} : { [keyName]: generateId() })), value)));\n\nfunction append(data, value) {\r\n    return [...convertToArrayPayload(data), ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...convertToArrayPayload(data)];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar updateAt = (fieldValues, index, value) => {\r\n    fieldValues[index] = value;\r\n    return fieldValues;\r\n};\n\nconst useFieldArray = (props) => {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, keyName = 'id', shouldUnregister, } = props;\r\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](mapIds(control._getFieldArrayValue(name), keyName));\r\n    const _fieldIds = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](fields);\r\n    _fieldIds.current = fields;\r\n    control._names.array.add(name);\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValuesWithKey = append(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValuesWithKey.length - appendValue.length, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const updatedFieldArrayValuesWithKey = prepend(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, 0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValuesWithKey = removeArrayAt(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValuesWithKey);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const updatedFieldArrayValuesWithKey = insert(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index, mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        swapArrayAt(updatedFieldArrayValuesWithKey, indexA, indexB);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        moveArrayAt(updatedFieldArrayValuesWithKey, from, to);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const update = (index, value) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        const updatedFieldArrayValues = updateAt(updatedFieldArrayValuesWithKey, index, value);\r\n        _fieldIds.current = mapIds(updatedFieldArrayValues, keyName);\r\n        setFields(_fieldIds.current);\r\n        control._updateFieldArray(keyName, name, updateAt, {\r\n            argA: index,\r\n            argB: value,\r\n        }, updatedFieldArrayValuesWithKey, true, false);\r\n    };\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        control._isInAction.val = false;\r\n        if (control._names.watchAll) {\r\n            control._subjects.state.next({});\r\n        }\r\n        else {\r\n            for (const watchField of control._names.watch) {\r\n                if (name.startsWith(watchField)) {\r\n                    control._subjects.state.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        control._subjects.watch.next({\r\n            name,\r\n            values: control._formValues,\r\n        });\r\n        control._names.focus &&\r\n            focusFieldBy(control._fields, (key) => key.startsWith(control._names.focus));\r\n        control._names.focus = '';\r\n        control._proxyFormState.isValid && control._updateValid();\r\n    }, [fields, name, control, keyName]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const fieldArraySubscription = control._subjects.array.subscribe({\r\n            next({ values, name: fieldArrayName }) {\r\n                if (fieldArrayName === name || !fieldArrayName) {\r\n                    setFields(mapIds(get(values, name), keyName));\r\n                }\r\n            },\r\n        });\r\n        !get(control._formValues, name) && set(control._formValues, name, []);\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            if (control._shouldUnregister || shouldUnregister) {\r\n                control.unregister(name);\r\n            }\r\n        };\r\n    }, [name, control, keyName, shouldUnregister]);\r\n    return {\r\n        swap: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](swap, [name, control, keyName]),\r\n        move: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](move, [name, control, keyName]),\r\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](prepend$1, [name, control, keyName]),\r\n        append: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](append$1, [name, control, keyName]),\r\n        remove: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](remove, [name, control, keyName]),\r\n        insert: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](insert$1, [name, control, keyName]),\r\n        update: react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"](update, [name, control, keyName]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction cloneObject(data) {\r\n    let copy;\r\n    const isArray = Array.isArray(data);\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n    }\r\n    else if (isArray || isObject(data)) {\r\n        copy = isArray ? [] : {};\r\n        for (const key in data) {\r\n            copy[key] = cloneObject(data[key]);\r\n        }\r\n    }\r\n    else {\r\n        return data;\r\n    }\r\n    return copy;\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        isDateObject(object1) ||\r\n        isDateObject(object2)) {\r\n        return object1 === object2;\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        const val1 = object1[key];\r\n        if (!keys2.includes(key)) {\r\n            return false;\r\n        }\r\n        if (key !== 'ref') {\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || Array.isArray(val1)) &&\r\n                (isObject(val2) || Array.isArray(val2))\r\n                ? !deepEqual(val1, val2)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nvar isString = (value) => typeof value === 'string';\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nvar live = (ref) => !isHTMLElement(ref) || !document.contains(ref);\n\nvar omitKey = (fields, keyName) => fields.map((field = {}) => omit(field, keyName));\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (field._f.refs ? field._f.refs.every((ref) => ref.disabled) : ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar getResolverOptions = (fieldsNames, _fieldss, criteriaMode, shouldUseNativeValidation) => {\r\n    const fields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(_fieldss, name);\r\n        field && set(fields, name, field._f);\r\n    }\r\n    return {\r\n        criteriaMode,\r\n        names: [...fieldsNames],\r\n        fields,\r\n        shouldUseNativeValidation,\r\n    };\r\n};\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                !isNullOrUndefined(defaultValues) &&\r\n                    deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar unsetEmptyArray = (ref, name) => !compact(get(ref, name, [])).length && unset(ref, name);\n\nvar isMessage = (value) => isString(value) || react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"](value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async (field, inputValue, validateAllFieldCriteria, shouldUseNativeValidation) => {\r\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, } = field._f;\r\n    if (!mount || disabled) {\r\n        return {};\r\n    }\r\n    const inputRef = refs ? refs[0] : ref;\r\n    const setCustomValidty = (message) => {\r\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\r\n            inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');\r\n            inputRef.reportValidity();\r\n        }\r\n    };\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: inputRef }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((maxLength || minLength) && !isEmpty && isString(inputValue)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty && isString(inputValue)) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, inputRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    setCustomValidty(validateError.message);\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const key in validate) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateError = getValidateError(await validate[key](inputValue), inputRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    setCustomValidty(validateError.message);\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: inputRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setCustomValidty(true);\r\n    return error;\r\n};\n\nconst defaultOptions = {\r\n    mode: VALIDATION_MODE.onSubmit,\r\n    reValidateMode: VALIDATION_MODE.onChange,\r\n    shouldFocusError: true,\r\n};\r\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction createFormControl(props = {}) {\r\n    let formOptions = Object.assign(Object.assign({}, defaultOptions), props);\r\n    let _delayCallback;\r\n    let _formState = {\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    };\r\n    let _fields = {};\r\n    let _formValues = {};\r\n    let _defaultValues = formOptions.defaultValues || {};\r\n    let _isInAction = false;\r\n    let _isMounted = false;\r\n    let _timer = 0;\r\n    let _names = {\r\n        mount: new Set(),\r\n        unMount: new Set(),\r\n        array: new Set(),\r\n        watch: new Set(),\r\n    };\r\n    let _validateCount = {};\r\n    const _proxyFormState = {\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    };\r\n    const _subjects = {\r\n        watch: new Subject(),\r\n        control: new Subject(),\r\n        array: new Subject(),\r\n        state: new Subject(),\r\n    };\r\n    const validationMode = getValidationModes(formOptions.mode);\r\n    const isValidateAllFieldCriteria = formOptions.criteriaMode === VALIDATION_MODE.all;\r\n    const debounce = (callback, wait) => (...args) => {\r\n        clearTimeout(_timer);\r\n        _timer = window.setTimeout(() => callback(...args), wait);\r\n    };\r\n    const isFieldWatched = (name) => _names.watchAll ||\r\n        _names.watch.has(name) ||\r\n        _names.watch.has((name.match(/\\w+/) || [])[0]);\r\n    const updateErrorState = (name, error) => {\r\n        set(_formState.errors, name, error);\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const shouldRenderBaseOnValid = async () => {\r\n        const isValid = await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const shouldRenderBaseOnError = async (shouldSkipRender, name, error, fieldState, isValidFromResolver, isWatched) => {\r\n        const previousError = get(_formState.errors, name);\r\n        const isValid = !!(_proxyFormState.isValid &&\r\n            (formOptions.resolver ? isValidFromResolver : shouldRenderBaseOnValid()));\r\n        if (props.delayError && error) {\r\n            _delayCallback =\r\n                _delayCallback || debounce(updateErrorState, props.delayError);\r\n            _delayCallback(name, error);\r\n        }\r\n        else {\r\n            clearTimeout(_timer);\r\n            error\r\n                ? set(_formState.errors, name, error)\r\n                : unset(_formState.errors, name);\r\n        }\r\n        if ((isWatched ||\r\n            (error ? !deepEqual(previousError, error) : previousError) ||\r\n            !isEmptyObject(fieldState) ||\r\n            _formState.isValid !== isValid) &&\r\n            !shouldSkipRender) {\r\n            const updatedFormState = Object.assign(Object.assign(Object.assign({}, fieldState), (_proxyFormState.isValid && formOptions.resolver ? { isValid } : {})), { errors: _formState.errors, name });\r\n            _formState = Object.assign(Object.assign({}, _formState), updatedFormState);\r\n            _subjects.state.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        _validateCount[name]--;\r\n        if (!_validateCount[name]) {\r\n            _subjects.state.next({\r\n                isValidating: false,\r\n            });\r\n            _validateCount = {};\r\n        }\r\n    };\r\n    const setFieldValue = (name, value, options = {}, shouldRender) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                set(_formValues, name, getFieldValueAs(value, _f));\r\n                const fieldValue = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(value)\r\n                    ? ''\r\n                    : value;\r\n                if (isFileInput(_f.ref) && !isString(fieldValue)) {\r\n                    _f.ref.files = fieldValue;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = fieldValue.includes(selectRef.value)));\r\n                }\r\n                else if (_f.refs) {\r\n                    if (isCheckBoxInput(_f.ref)) {\r\n                        _f.refs.length > 1\r\n                            ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(fieldValue)\r\n                                ? !!fieldValue.find((data) => data === checkboxRef.value)\r\n                                : fieldValue === checkboxRef.value))\r\n                            : (_f.refs[0].checked = !!fieldValue);\r\n                    }\r\n                    else {\r\n                        _f.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));\r\n                    }\r\n                }\r\n                else {\r\n                    _f.ref.value = fieldValue;\r\n                }\r\n                if (shouldRender) {\r\n                    _subjects.control.next({\r\n                        values: getValues(),\r\n                        name,\r\n                    });\r\n                }\r\n                (options.shouldDirty || options.shouldTouch) &&\r\n                    updateTouchAndDirtyState(name, fieldValue, options.shouldTouch);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n        }\r\n    };\r\n    const updateTouchAndDirtyState = (name, inputValue, isCurrentTouched, shouldRender = true) => {\r\n        const state = {\r\n            name,\r\n        };\r\n        let isChanged = false;\r\n        if (_proxyFormState.isDirty) {\r\n            const previousIsDirty = _formState.isDirty;\r\n            _formState.isDirty = _getIsDirty();\r\n            state.isDirty = _formState.isDirty;\r\n            isChanged = previousIsDirty !== state.isDirty;\r\n        }\r\n        if (_proxyFormState.dirtyFields && !isCurrentTouched) {\r\n            const isPreviousFieldDirty = get(_formState.dirtyFields, name);\r\n            const isCurrentFieldDirty = !deepEqual(get(_defaultValues, name), inputValue);\r\n            isCurrentFieldDirty\r\n                ? set(_formState.dirtyFields, name, true)\r\n                : unset(_formState.dirtyFields, name);\r\n            state.dirtyFields = _formState.dirtyFields;\r\n            isChanged =\r\n                isChanged || isPreviousFieldDirty !== get(_formState.dirtyFields, name);\r\n        }\r\n        const isPreviousFieldTouched = get(_formState.touchedFields, name);\r\n        if (isCurrentTouched && !isPreviousFieldTouched) {\r\n            set(_formState.touchedFields, name, isCurrentTouched);\r\n            state.touchedFields = _formState.touchedFields;\r\n            isChanged =\r\n                isChanged ||\r\n                    (_proxyFormState.touchedFields &&\r\n                        isPreviousFieldTouched !== isCurrentTouched);\r\n        }\r\n        isChanged && shouldRender && _subjects.state.next(state);\r\n        return isChanged ? state : {};\r\n    };\r\n    const executeResolver = async (name) => {\r\n        return formOptions.resolver\r\n            ? await formOptions.resolver(Object.assign({}, _formValues), formOptions.context, getResolverOptions(name || _names.mount, _fields, formOptions.criteriaMode, formOptions.shouldUseNativeValidation))\r\n            : {};\r\n    };\r\n    const executeResolverValidation = async (names) => {\r\n        const { errors } = await executeResolver();\r\n        if (names) {\r\n            for (const name of names) {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(_formState.errors, name, error)\r\n                    : unset(_formState.errors, name);\r\n            }\r\n        }\r\n        else {\r\n            _formState.errors = errors;\r\n        }\r\n        return errors;\r\n    };\r\n    const validateForm = async (_fields, shouldCheckValid, context = {\r\n        valid: true,\r\n    }) => {\r\n        for (const name in _fields) {\r\n            const field = _fields[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const val = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, get(_formValues, _f.name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation);\r\n                    if (shouldCheckValid) {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                        }\r\n                        fieldError[_f.name]\r\n                            ? set(_formState.errors, _f.name, fieldError[_f.name])\r\n                            : unset(_formState.errors, _f.name);\r\n                    }\r\n                }\r\n                val && (await validateForm(val, shouldCheckValid, context));\r\n            }\r\n        }\r\n        return context.valid;\r\n    };\r\n    const handleChange = async ({ type, target, target: { value, name, type: inputType }, }) => {\r\n        let error;\r\n        let isValid;\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange } = getValidationModes(formOptions.reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !formOptions.resolver &&\r\n                !get(_formState.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(_formState.touchedFields, name), isSubmitted: _formState.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                set(_formValues, name, inputValue);\r\n            }\r\n            const fieldState = updateTouchAndDirtyState(name, inputValue, isBlurEvent, false);\r\n            const shouldRender = !isEmptyObject(fieldState) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    _subjects.watch.next({\r\n                        name,\r\n                        type,\r\n                    });\r\n                return (shouldRender &&\r\n                    _subjects.state.next(isWatched ? { name } : Object.assign(Object.assign({}, fieldState), { name })));\r\n            }\r\n            _validateCount[name] = _validateCount[name] ? +1 : 1;\r\n            _subjects.state.next({\r\n                isValidating: true,\r\n            });\r\n            if (formOptions.resolver) {\r\n                const { errors } = await executeResolver([name]);\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const valError = get(errors, parentNodeName, {});\r\n                    valError.type && valError.message && (error = valError);\r\n                    if (valError || get(_formState.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n            }\r\n            else {\r\n                error = (await validateField(field, get(_formValues, name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                _subjects.watch.next({\r\n                    name,\r\n                    type,\r\n                    values: getValues(),\r\n                });\r\n            shouldRenderBaseOnError(false, name, error, fieldState, isValid, isWatched);\r\n        }\r\n    };\r\n    const _updateValidAndInputValue = (name, ref, shouldSkipValueAs) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const fieldValue = get(_formValues, name);\r\n            const isValueUndefined = isUndefined(fieldValue);\r\n            const defaultValue = isValueUndefined\r\n                ? get(_defaultValues, name)\r\n                : fieldValue;\r\n            if (isUndefined(defaultValue) ||\r\n                (ref && ref.defaultChecked) ||\r\n                shouldSkipValueAs) {\r\n                set(_formValues, name, shouldSkipValueAs ? defaultValue : getFieldValue(field));\r\n            }\r\n            else {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        _isMounted && _proxyFormState.isValid && _updateValid();\r\n    };\r\n    const _getIsDirty = (name, data) => {\r\n        name && data && set(_formValues, name, data);\r\n        return !deepEqual(Object.assign({}, getValues()), _defaultValues);\r\n    };\r\n    const _updateValid = async () => {\r\n        const isValid = formOptions.resolver\r\n            ? isEmptyObject((await executeResolver()).errors)\r\n            : await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const setValues = (name, value, options) => Object.entries(value).forEach(([fieldKey, fieldValue]) => {\r\n        const fieldName = `${name}.${fieldKey}`;\r\n        const field = get(_fields, fieldName);\r\n        const isFieldArray = _names.array.has(name);\r\n        (isFieldArray || !isPrimitive(fieldValue) || (field && !field._f)) &&\r\n            !isDateObject(fieldValue)\r\n            ? setValues(fieldName, fieldValue, options)\r\n            : setFieldValue(fieldName, fieldValue, options, true);\r\n    });\r\n    const _getWatch = (fieldNames, defaultValue, isGlobal) => {\r\n        const fieldValues = Object.assign({}, (_isMounted\r\n            ? _formValues\r\n            : isUndefined(defaultValue)\r\n                ? _defaultValues\r\n                : isString(fieldNames)\r\n                    ? { [fieldNames]: defaultValue }\r\n                    : defaultValue));\r\n        if (!fieldNames) {\r\n            isGlobal && (_names.watchAll = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && _names.watch.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return Array.isArray(fieldNames)\r\n            ? result\r\n            : isObject(result[0])\r\n                ? Object.assign({}, result[0]) : Array.isArray(result[0])\r\n                ? [...result[0]]\r\n                : result[0];\r\n    };\r\n    const _updateValues = (defaultValues, name = '') => {\r\n        for (const key in defaultValues) {\r\n            const value = defaultValues[key];\r\n            const fieldName = name + (name ? '.' : '') + key;\r\n            const field = get(_fields, fieldName);\r\n            if (!field || !field._f) {\r\n                if (isObject(value) || Array.isArray(value)) {\r\n                    _updateValues(value, fieldName);\r\n                }\r\n                else if (!field) {\r\n                    set(_formValues, fieldName, value);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const _updateFieldArray = (keyName, name, method, args, updatedFieldArrayValuesWithKey = [], shouldSet = true, shouldSetFields = true) => {\r\n        let output;\r\n        const updatedFieldArrayValues = omitKey(updatedFieldArrayValuesWithKey, keyName);\r\n        _isInAction = true;\r\n        if (shouldSetFields && get(_fields, name)) {\r\n            output = method(get(_fields, name), args.argA, args.argB);\r\n            shouldSet && set(_fields, name, output);\r\n        }\r\n        output = method(get(_formValues, name), args.argA, args.argB);\r\n        shouldSet && set(_formValues, name, output);\r\n        if (Array.isArray(get(_formState.errors, name))) {\r\n            const output = method(get(_formState.errors, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.errors, name, output);\r\n            unsetEmptyArray(_formState.errors, name);\r\n        }\r\n        if (_proxyFormState.touchedFields && get(_formState.touchedFields, name)) {\r\n            const output = method(get(_formState.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.touchedFields, name, output);\r\n            unsetEmptyArray(_formState.touchedFields, name);\r\n        }\r\n        if (_proxyFormState.dirtyFields || _proxyFormState.isDirty) {\r\n            set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            updatedFieldArrayValues &&\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            unsetEmptyArray(_formState.dirtyFields, name);\r\n        }\r\n        _subjects.state.next({\r\n            isDirty: _getIsDirty(name, omitKey(updatedFieldArrayValues, keyName)),\r\n            dirtyFields: _formState.dirtyFields,\r\n            errors: _formState.errors,\r\n            isValid: _formState.isValid,\r\n        });\r\n    };\r\n    const _getFieldArrayValue = (name) => get(_isMounted ? _formValues : _defaultValues, name, []);\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(_fields, name);\r\n        const isFieldArray = _names.array.has(name);\r\n        set(_formValues, name, value);\r\n        if (isFieldArray) {\r\n            _subjects.array.next({\r\n                name,\r\n                values: _formValues,\r\n            });\r\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(value, get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n                _subjects.state.next({\r\n                    name,\r\n                    dirtyFields: _formState.dirtyFields,\r\n                    isDirty: _getIsDirty(name, value),\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            field && !field._f && !isNullOrUndefined(value)\r\n                ? setValues(name, value, options)\r\n                : setFieldValue(name, value, options, true);\r\n        }\r\n        isFieldWatched(name) && _subjects.state.next({});\r\n        _subjects.watch.next({\r\n            name,\r\n        });\r\n    };\r\n    const trigger = async (name, options = {}) => {\r\n        const fieldNames = convertToArrayPayload(name);\r\n        let isValid;\r\n        _subjects.state.next({\r\n            isValidating: true,\r\n        });\r\n        if (formOptions.resolver) {\r\n            const schemaResult = await executeResolverValidation(isUndefined(name) ? name : fieldNames);\r\n            isValid = name\r\n                ? fieldNames.every((name) => !get(schemaResult, name))\r\n                : isEmptyObject(schemaResult);\r\n        }\r\n        else {\r\n            if (name) {\r\n                isValid = (await Promise.all(fieldNames.map(async (fieldName) => {\r\n                    const field = get(_fields, fieldName);\r\n                    return await validateForm(field._f ? { [fieldName]: field } : field);\r\n                }))).every(Boolean);\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n                isValid = isEmptyObject(_formState.errors);\r\n            }\r\n        }\r\n        _subjects.state.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: _formState.errors, isValidating: false }));\r\n        if (options.shouldFocus && !isValid) {\r\n            focusFieldBy(_fields, (key) => get(_formState.errors, key), name ? fieldNames : _names.mount);\r\n        }\r\n        _proxyFormState.isValid && _updateValid();\r\n        return isValid;\r\n    };\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, _defaultValues), _formValues);\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName))\r\n            : (_formState.errors = {});\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;\r\n        set(_formState.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        _subjects.state.next({\r\n            name,\r\n            errors: _formState.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? _subjects.watch.subscribe({\r\n            next: (info) => fieldName(_getWatch(undefined, defaultValue), info),\r\n        })\r\n        : _getWatch(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name ? convertToArrayPayload(name) : _names.mount) {\r\n            _names.mount.delete(inputName);\r\n            _names.array.delete(inputName);\r\n            if (get(_fields, inputName)) {\r\n                if (!options.keepValue) {\r\n                    unset(_fields, inputName);\r\n                    unset(_formValues, inputName);\r\n                }\r\n                !options.keepError && unset(_formState.errors, inputName);\r\n                !options.keepDirty && unset(_formState.dirtyFields, inputName);\r\n                !options.keepTouched && unset(_formState.touchedFields, inputName);\r\n                !formOptions.shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(_defaultValues, inputName);\r\n            }\r\n        }\r\n        _subjects.watch.next({});\r\n        _subjects.state.next(Object.assign(Object.assign({}, _formState), (!options.keepDirty ? {} : { isDirty: _getIsDirty() })));\r\n        !options.keepIsValid && _updateValid();\r\n    };\r\n    const registerFieldRef = (name, fieldRef, options) => {\r\n        register(name, options);\r\n        let field = get(_fields, name);\r\n        const ref = isUndefined(fieldRef.value)\r\n            ? fieldRef.querySelectorAll\r\n                ? fieldRef.querySelectorAll('input,select,textarea')[0] ||\r\n                    fieldRef\r\n                : fieldRef\r\n            : fieldRef;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isRadioOrCheckbox &&\r\n                compact(field._f.refs || []).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(_fields, name, field);\r\n        _updateValidAndInputValue(name, ref);\r\n    };\r\n    const register = (name, options = {}) => {\r\n        const field = get(_fields, name);\r\n        set(_fields, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        if (options.value) {\r\n            set(_formValues, name, options.value);\r\n        }\r\n        if (!isUndefined(options.disabled) &&\r\n            field &&\r\n            field._f &&\r\n            field._f.ref.disabled !== options.disabled) {\r\n            set(_formValues, name, options.disabled ? undefined : field._f.ref.value);\r\n        }\r\n        _names.mount.add(name);\r\n        !field && _updateValidAndInputValue(name, undefined, true);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : Object.assign(Object.assign({ name }, (isUndefined(options.disabled)\r\n                ? {}\r\n                : { disabled: options.disabled })), { onChange: handleChange, onBlur: handleChange, ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(_fields, name, {});\r\n                        const _shouldUnregister = formOptions.shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                        }\r\n                        _shouldUnregister &&\r\n                            !(isNameInFieldArray(_names.array, name) && _isInAction) &&\r\n                            _names.unMount.add(name);\r\n                    }\r\n                } });\r\n    };\r\n    const handleSubmit = (onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = Object.assign({}, _formValues);\r\n        _subjects.state.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (formOptions.resolver) {\r\n                const { errors, values } = await executeResolver();\r\n                _formState.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n            }\r\n            if (isEmptyObject(_formState.errors) &&\r\n                Object.keys(_formState.errors).every((name) => get(fieldValues, name))) {\r\n                _subjects.state.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(_formState.errors, e));\r\n                formOptions.shouldFocusError &&\r\n                    focusFieldBy(_fields, (key) => get(_formState.errors, key), _names.mount);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            _formState.isSubmitted = true;\r\n            _subjects.state.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && hasNoPromiseError,\r\n                submitCount: _formState.submitCount + 1,\r\n                errors: _formState.errors,\r\n            });\r\n        }\r\n    };\r\n    const reset = (formValues, keepStateOptions = {}) => {\r\n        const updatedValues = formValues || _defaultValues;\r\n        const values = cloneObject(updatedValues);\r\n        _formValues = values;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of _names.mount) {\r\n                const field = get(_fields, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        if (!keepStateOptions.keepDefaultValues) {\r\n            _defaultValues = Object.assign({}, updatedValues);\r\n        }\r\n        if (!keepStateOptions.keepValues) {\r\n            _fields = {};\r\n            _subjects.control.next({\r\n                values: keepStateOptions.keepDefaultValues\r\n                    ? _defaultValues\r\n                    : Object.assign({}, updatedValues),\r\n            });\r\n            _subjects.watch.next({});\r\n            _subjects.array.next({\r\n                values,\r\n            });\r\n        }\r\n        _names = {\r\n            mount: new Set(),\r\n            unMount: new Set(),\r\n            array: new Set(),\r\n            watch: new Set(),\r\n            watchAll: false,\r\n            focus: '',\r\n        };\r\n        _subjects.state.next({\r\n            submitCount: keepStateOptions.keepSubmitCount\r\n                ? _formState.submitCount\r\n                : 0,\r\n            isDirty: keepStateOptions.keepDirty\r\n                ? _formState.isDirty\r\n                : keepStateOptions.keepDefaultValues\r\n                    ? deepEqual(formValues, _defaultValues)\r\n                    : false,\r\n            isSubmitted: keepStateOptions.keepIsSubmitted\r\n                ? _formState.isSubmitted\r\n                : false,\r\n            dirtyFields: keepStateOptions.keepDirty ? _formState.dirtyFields : {},\r\n            touchedFields: keepStateOptions.keepTouched\r\n                ? _formState.touchedFields\r\n                : {},\r\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n        _isMounted = !!keepStateOptions.keepIsValid;\r\n    };\r\n    const setFocus = (name) => get(_fields, name)._f.ref.focus();\r\n    const _removeFields = () => {\r\n        for (const name of _names.unMount) {\r\n            const field = get(_fields, name);\r\n            field &&\r\n                (field._f.refs ? field._f.refs.every(live) : live(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        _names.unMount = new Set();\r\n    };\r\n    return {\r\n        control: {\r\n            register,\r\n            unregister,\r\n            _getWatch,\r\n            _getIsDirty,\r\n            _updateValid,\r\n            _updateValues,\r\n            _removeFields,\r\n            _updateFieldArray,\r\n            _getFieldArrayValue,\r\n            _subjects,\r\n            _shouldUnregister: formOptions.shouldUnregister,\r\n            _fields,\r\n            _proxyFormState,\r\n            get _formValues() {\r\n                return _formValues;\r\n            },\r\n            set _formValues(value) {\r\n                _formValues = value;\r\n            },\r\n            get _isMounted() {\r\n                return _isMounted;\r\n            },\r\n            set _isMounted(value) {\r\n                _isMounted = value;\r\n            },\r\n            get _defaultValues() {\r\n                return _defaultValues;\r\n            },\r\n            set _defaultValues(value) {\r\n                _defaultValues = value;\r\n            },\r\n            get _names() {\r\n                return _names;\r\n            },\r\n            set _names(value) {\r\n                _names = value;\r\n            },\r\n            _isInAction: {\r\n                get val() {\r\n                    return _isInAction;\r\n                },\r\n                set val(value) {\r\n                    _isInAction = value;\r\n                },\r\n            },\r\n            _formState: {\r\n                get val() {\r\n                    return _formState;\r\n                },\r\n                set val(value) {\r\n                    _formState = value;\r\n                },\r\n            },\r\n            _updateProps: (options) => {\r\n                formOptions = Object.assign(Object.assign({}, defaultOptions), options);\r\n            },\r\n        },\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch,\r\n        setValue,\r\n        getValues,\r\n        reset,\r\n        clearErrors,\r\n        unregister,\r\n        setError,\r\n        setFocus,\r\n    };\r\n}\n\nfunction useForm(props = {}) {\r\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"]();\r\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"]({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    });\r\n    if (_formControl.current) {\r\n        _formControl.current.control._updateProps(props);\r\n    }\r\n    else {\r\n        _formControl.current = Object.assign(Object.assign({}, createFormControl(props)), { formState });\r\n    }\r\n    const control = _formControl.current.control;\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, control._proxyFormState, true)) {\r\n                    control._formState.val = Object.assign(Object.assign({}, control._formState.val), formState);\r\n                    updateFormState(Object.assign({}, control._formState.val));\r\n                }\r\n            },\r\n        });\r\n        return () => {\r\n            formStateSubscription.unsubscribe();\r\n        };\r\n    }, [control]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        if (!control._isMounted) {\r\n            control._isMounted = true;\r\n            control._proxyFormState.isValid && control._updateValid();\r\n            !props.shouldUnregister && control._updateValues(control._defaultValues);\r\n        }\r\n        control._removeFields();\r\n    });\r\n    _formControl.current.formState = getProxyFormState(formState, control._proxyFormState);\r\n    return _formControl.current;\r\n}\n\nfunction useWatch(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, defaultValue, disabled, } = props || {};\r\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"](name);\r\n    _name.current = name;\r\n    const [value, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"](isUndefined(defaultValue)\r\n        ? control._getWatch(name)\r\n        : defaultValue);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        const watchSubscription = control._subjects.watch.subscribe({\r\n            next: ({ name }) => {\r\n                (!_name.current ||\r\n                    !name ||\r\n                    convertToArrayPayload(_name.current).some((fieldName) => name &&\r\n                        fieldName &&\r\n                        (fieldName.startsWith(name) ||\r\n                            name.startsWith(fieldName)))) &&\r\n                    updateValue(control._getWatch(_name.current, defaultValue));\r\n            },\r\n        });\r\n        disabled && watchSubscription.unsubscribe();\r\n        return () => watchSubscription.unsubscribe();\r\n    }, [disabled, control, defaultValue]);\r\n    react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"](() => {\r\n        control._removeFields();\r\n    });\r\n    return value;\r\n}\n\n\n//# sourceMappingURL=index.esm.js.map\n\n\n/***/ }),\n\n/***/ \"cpVT\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return _defineProperty; });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["/home/whiteshadow/projects/benchmark-advisors/node_modules/react-hook-form/dist/index.esm.js","/home/whiteshadow/projects/benchmark-advisors/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+B;;AAE/B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA,oBAAoB,mDAAmB;AACvC;AACA,6BAA6B,gDAAgB;AAC7C,iCAAiC,mDAAmB,wBAAwB,iCAAiC;;AAE7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,4CAA4C;AACvD,oBAAoB,4CAAY;AAChC,yCAAyC,8CAAc;AACvD,iCAAiC,4CAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,+CAAe;AACnB;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,oDAAoD;AAC/D,wCAAwC,8CAAc;AACtD;AACA;AACA;AACA,KAAK;AACL,+EAA+E,iBAAiB,QAAQ;AACxG,0BAA0B,iDAAiB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA,oCAAoC,kBAAkB,sCAAsC,+DAA+D,KAAK,0BAA0B,GAAG;;AAE7L;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,KAAK,GAAG,mBAAmB;AACzD,SAAS,KAAK,GAAG,MAAM;;AAEvB;AACA;AACA,yCAAyC,qBAAqB,6BAA6B,KAAK;AAChG,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA,4FAA4F,sBAAsB,IAAI,0BAA0B;;AAEhJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,qEAAqE;AAChF,gCAAgC,8CAAc;AAC9C,sBAAsB,4CAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,IAAI,+CAAe;AACnB;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,iDAAiB;AAC/B,cAAc,iDAAiB;AAC/B,iBAAiB,iDAAiB;AAClC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC,gBAAgB,iDAAiB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,yDAAyD;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,WAAW;AACzB,WAAW,QAAQ;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,iFAAiF;AACjF;AACA;AACA;AACA,4DAA4D;AAC5D,kDAAkD;AAClD,0EAA0E,wBAAwB,cAAc;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,2HAA2H;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,oDAAoB;;AAElE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,gHAAgH;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,eAAe;AACf;AACA;AACA,yCAAyC,gEAAgE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA,yCAAyC;AACzC,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,oDAAoD;AACpD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,mEAAmE,UAAU,KAAK,KAAK,kCAAkC;AAC1M,uDAAuD;AACvD,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,+BAA+B,GAAG;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAiE;AACpF;AACA;AACA;AACA,8CAA8C;AAC9C,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sDAAsD,OAAO,iCAAiC,gBAAgB,OAAO;AACrH;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,6BAA6B,KAAK,GAAG,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,SAAS;AACT;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,qBAAqB,OAAO,KAAK,KAAK,iDAAiD;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,OAAO,EAAE,UAAU;AAC5D,mEAAmE,WAAW,MAAM;AACpF;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,2DAA2D,uCAAuC,IAAI,yBAAyB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D;AACA;AACA,6BAA6B,uBAAuB,EAAE,kCAAkC,cAAc,MAAM;AAC5G;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,4DAA4D,mCAAmC,OAAO,OAAO,EAAE,KAAK,oBAAoB;AACxI,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,2CAA2C,OAAO;AAClD;AACA,mBAAmB,6BAA6B,KAAK;AACrD;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,EAAE;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,aAAa;AACb,mCAAmC;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA,oBAAoB;AACpB,wEAAwE;AACxE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,4DAA4D;AAC5D,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;AAC3B,yBAAyB,4CAAY;AACrC,yCAAyC,8CAAc;AACvD;AACA;AACA,uBAAuB;AACvB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,kBAAkB;AAClB,KAAK;AACL;AACA;AACA;AACA;AACA,6DAA6D,8BAA8B,YAAY;AACvG;AACA;AACA,IAAI,+CAAe;AACnB;AACA;AACA;AACA,2EAA2E;AAC3E,oDAAoD;AACpD;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,2DAA2D;AACtE,kBAAkB,4CAAY;AAC9B;AACA,iCAAiC,8CAAc;AAC/C;AACA;AACA,IAAI,+CAAe;AACnB;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,KAAK;AACL,IAAI,+CAAe;AACnB;AACA,KAAK;AACL;AACA;;AAE2I;AAC3I;;;;;;;;;ACzvDA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA,C","file":"x","sourcesContent":["import * as React from 'react';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isDateObject = (data) => data instanceof Date;\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !isDateObject(value);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = React.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => React.useContext(FormContext);\r\nconst FormProvider = (props) => (React.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (formState, _proxyFormState, localProxyFormState, isRoot = true) => {\r\n    function createGetter(prop) {\r\n        return () => {\r\n            if (prop in formState) {\r\n                if (_proxyFormState[prop] !== VALIDATION_MODE.all) {\r\n                    _proxyFormState[prop] = !isRoot || VALIDATION_MODE.all;\r\n                }\r\n                localProxyFormState && (localProxyFormState[prop] = true);\r\n                return formState[prop];\r\n            }\r\n            return undefined;\r\n        };\r\n    }\r\n    const result = {};\r\n    for (const key in formState) {\r\n        Object.defineProperty(result, key, {\r\n            get: createGetter(key),\r\n        });\r\n    }\r\n    return result;\r\n};\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, _proxyFormState, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||\r\n        Object.keys(formState).find((key) => _proxyFormState[key] ===\r\n            (!isRoot || VALIDATION_MODE.all)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nfunction useFormState(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, disabled, name } = props || {};\r\n    const nameRef = React.useRef(name);\r\n    const [formState, updateFormState] = React.useState(control._formState.val);\r\n    const _localProxyFormState = React.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    nameRef.current = name;\r\n    React.useEffect(() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, _localProxyFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, control._formState.val), formState)),\r\n        });\r\n        disabled && formStateSubscription.unsubscribe();\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, [disabled, control]);\r\n    return getProxyFormState(formState, control._proxyFormState, _localProxyFormState.current, false);\r\n}\n\nfunction useController(props) {\r\n    const methods = useFormContext();\r\n    const { name, control = methods.control, shouldUnregister } = props;\r\n    const [value, setInputStateValue] = React.useState(get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)));\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    const registerProps = control.register(name, Object.assign(Object.assign({}, props.rules), { value }));\r\n    const updateMounted = React.useCallback((name, value) => {\r\n        const field = get(control._fields, name);\r\n        if (field) {\r\n            field._f.mount = value;\r\n        }\r\n    }, [control]);\r\n    React.useEffect(() => {\r\n        const controllerSubscription = control._subjects.control.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        updateMounted(name, true);\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const _shouldUnregisterField = control._shouldUnregister || shouldUnregister;\r\n            if (isNameInFieldArray(control._names.array, name)\r\n                ? _shouldUnregisterField && !control._isInAction.val\r\n                : _shouldUnregisterField) {\r\n                control.unregister(name);\r\n            }\r\n            else {\r\n                updateMounted(name, false);\r\n            }\r\n        };\r\n    }, [name, control, shouldUnregister, updateMounted]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                registerProps.onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                registerProps.onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm &&\r\n                registerProps.ref({\r\n                    focus: () => elm.focus && elm.focus(),\r\n                    setCustomValidity: (message) => elm.setCustomValidity(message),\r\n                    reportValidity: () => elm.reportValidity(),\r\n                }),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nvar getFocusFieldName = (name, index, options) => options && !options.shouldFocus\r\n    ? options.focusName || `${name}.${options.focusIndex}.`\r\n    : `${name}.${index}.`;\n\nvar mapCurrentIds = (values, _fieldIds, keyName) => values.map((value, index) => {\r\n    const output = _fieldIds.current[index];\r\n    return Object.assign(Object.assign({}, value), (output ? { [keyName]: output[keyName] } : {}));\r\n});\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign(Object.assign({}, (value[keyName] ? {} : { [keyName]: generateId() })), value)));\n\nfunction append(data, value) {\r\n    return [...convertToArrayPayload(data), ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...convertToArrayPayload(data)];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar updateAt = (fieldValues, index, value) => {\r\n    fieldValues[index] = value;\r\n    return fieldValues;\r\n};\n\nconst useFieldArray = (props) => {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, keyName = 'id', shouldUnregister, } = props;\r\n    const [fields, setFields] = React.useState(mapIds(control._getFieldArrayValue(name), keyName));\r\n    const _fieldIds = React.useRef(fields);\r\n    _fieldIds.current = fields;\r\n    control._names.array.add(name);\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValuesWithKey = append(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValuesWithKey.length - appendValue.length, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const updatedFieldArrayValuesWithKey = prepend(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, 0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValuesWithKey = removeArrayAt(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValuesWithKey);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const updatedFieldArrayValuesWithKey = insert(mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName), index, mapIds(convertToArrayPayload(value), keyName));\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValuesWithKey);\r\n        control._names.focus = getFocusFieldName(name, index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        swapArrayAt(updatedFieldArrayValuesWithKey, indexA, indexB);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        moveArrayAt(updatedFieldArrayValuesWithKey, from, to);\r\n        setFields(updatedFieldArrayValuesWithKey);\r\n        control._updateFieldArray(keyName, name, moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, updatedFieldArrayValuesWithKey, false);\r\n    };\r\n    const update = (index, value) => {\r\n        const updatedFieldArrayValuesWithKey = mapCurrentIds(control._getFieldArrayValue(name), _fieldIds, keyName);\r\n        const updatedFieldArrayValues = updateAt(updatedFieldArrayValuesWithKey, index, value);\r\n        _fieldIds.current = mapIds(updatedFieldArrayValues, keyName);\r\n        setFields(_fieldIds.current);\r\n        control._updateFieldArray(keyName, name, updateAt, {\r\n            argA: index,\r\n            argB: value,\r\n        }, updatedFieldArrayValuesWithKey, true, false);\r\n    };\r\n    React.useEffect(() => {\r\n        control._isInAction.val = false;\r\n        if (control._names.watchAll) {\r\n            control._subjects.state.next({});\r\n        }\r\n        else {\r\n            for (const watchField of control._names.watch) {\r\n                if (name.startsWith(watchField)) {\r\n                    control._subjects.state.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        control._subjects.watch.next({\r\n            name,\r\n            values: control._formValues,\r\n        });\r\n        control._names.focus &&\r\n            focusFieldBy(control._fields, (key) => key.startsWith(control._names.focus));\r\n        control._names.focus = '';\r\n        control._proxyFormState.isValid && control._updateValid();\r\n    }, [fields, name, control, keyName]);\r\n    React.useEffect(() => {\r\n        const fieldArraySubscription = control._subjects.array.subscribe({\r\n            next({ values, name: fieldArrayName }) {\r\n                if (fieldArrayName === name || !fieldArrayName) {\r\n                    setFields(mapIds(get(values, name), keyName));\r\n                }\r\n            },\r\n        });\r\n        !get(control._formValues, name) && set(control._formValues, name, []);\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            if (control._shouldUnregister || shouldUnregister) {\r\n                control.unregister(name);\r\n            }\r\n        };\r\n    }, [name, control, keyName, shouldUnregister]);\r\n    return {\r\n        swap: React.useCallback(swap, [name, control, keyName]),\r\n        move: React.useCallback(move, [name, control, keyName]),\r\n        prepend: React.useCallback(prepend$1, [name, control, keyName]),\r\n        append: React.useCallback(append$1, [name, control, keyName]),\r\n        remove: React.useCallback(remove, [name, control, keyName]),\r\n        insert: React.useCallback(insert$1, [name, control, keyName]),\r\n        update: React.useCallback(update, [name, control, keyName]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction cloneObject(data) {\r\n    let copy;\r\n    const isArray = Array.isArray(data);\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n    }\r\n    else if (isArray || isObject(data)) {\r\n        copy = isArray ? [] : {};\r\n        for (const key in data) {\r\n            copy[key] = cloneObject(data[key]);\r\n        }\r\n    }\r\n    else {\r\n        return data;\r\n    }\r\n    return copy;\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        isDateObject(object1) ||\r\n        isDateObject(object2)) {\r\n        return object1 === object2;\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        const val1 = object1[key];\r\n        if (!keys2.includes(key)) {\r\n            return false;\r\n        }\r\n        if (key !== 'ref') {\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || Array.isArray(val1)) &&\r\n                (isObject(val2) || Array.isArray(val2))\r\n                ? !deepEqual(val1, val2)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nvar isString = (value) => typeof value === 'string';\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nvar live = (ref) => !isHTMLElement(ref) || !document.contains(ref);\n\nvar omitKey = (fields, keyName) => fields.map((field = {}) => omit(field, keyName));\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (field._f.refs ? field._f.refs.every((ref) => ref.disabled) : ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar getResolverOptions = (fieldsNames, _fieldss, criteriaMode, shouldUseNativeValidation) => {\r\n    const fields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(_fieldss, name);\r\n        field && set(fields, name, field._f);\r\n    }\r\n    return {\r\n        criteriaMode,\r\n        names: [...fieldsNames],\r\n        fields,\r\n        shouldUseNativeValidation,\r\n    };\r\n};\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                !isNullOrUndefined(defaultValues) &&\r\n                    deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar unsetEmptyArray = (ref, name) => !compact(get(ref, name, [])).length && unset(ref, name);\n\nvar isMessage = (value) => isString(value) || React.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async (field, inputValue, validateAllFieldCriteria, shouldUseNativeValidation) => {\r\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, } = field._f;\r\n    if (!mount || disabled) {\r\n        return {};\r\n    }\r\n    const inputRef = refs ? refs[0] : ref;\r\n    const setCustomValidty = (message) => {\r\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\r\n            inputRef.setCustomValidity(isBoolean(message) ? '' : message || ' ');\r\n            inputRef.reportValidity();\r\n        }\r\n    };\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: inputRef }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((maxLength || minLength) && !isEmpty && isString(inputValue)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(error[name].message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty && isString(inputValue)) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                setCustomValidty(message);\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, inputRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    setCustomValidty(validateError.message);\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const key in validate) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateError = getValidateError(await validate[key](inputValue), inputRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    setCustomValidty(validateError.message);\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: inputRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setCustomValidty(true);\r\n    return error;\r\n};\n\nconst defaultOptions = {\r\n    mode: VALIDATION_MODE.onSubmit,\r\n    reValidateMode: VALIDATION_MODE.onChange,\r\n    shouldFocusError: true,\r\n};\r\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction createFormControl(props = {}) {\r\n    let formOptions = Object.assign(Object.assign({}, defaultOptions), props);\r\n    let _delayCallback;\r\n    let _formState = {\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    };\r\n    let _fields = {};\r\n    let _formValues = {};\r\n    let _defaultValues = formOptions.defaultValues || {};\r\n    let _isInAction = false;\r\n    let _isMounted = false;\r\n    let _timer = 0;\r\n    let _names = {\r\n        mount: new Set(),\r\n        unMount: new Set(),\r\n        array: new Set(),\r\n        watch: new Set(),\r\n    };\r\n    let _validateCount = {};\r\n    const _proxyFormState = {\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    };\r\n    const _subjects = {\r\n        watch: new Subject(),\r\n        control: new Subject(),\r\n        array: new Subject(),\r\n        state: new Subject(),\r\n    };\r\n    const validationMode = getValidationModes(formOptions.mode);\r\n    const isValidateAllFieldCriteria = formOptions.criteriaMode === VALIDATION_MODE.all;\r\n    const debounce = (callback, wait) => (...args) => {\r\n        clearTimeout(_timer);\r\n        _timer = window.setTimeout(() => callback(...args), wait);\r\n    };\r\n    const isFieldWatched = (name) => _names.watchAll ||\r\n        _names.watch.has(name) ||\r\n        _names.watch.has((name.match(/\\w+/) || [])[0]);\r\n    const updateErrorState = (name, error) => {\r\n        set(_formState.errors, name, error);\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const shouldRenderBaseOnValid = async () => {\r\n        const isValid = await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const shouldRenderBaseOnError = async (shouldSkipRender, name, error, fieldState, isValidFromResolver, isWatched) => {\r\n        const previousError = get(_formState.errors, name);\r\n        const isValid = !!(_proxyFormState.isValid &&\r\n            (formOptions.resolver ? isValidFromResolver : shouldRenderBaseOnValid()));\r\n        if (props.delayError && error) {\r\n            _delayCallback =\r\n                _delayCallback || debounce(updateErrorState, props.delayError);\r\n            _delayCallback(name, error);\r\n        }\r\n        else {\r\n            clearTimeout(_timer);\r\n            error\r\n                ? set(_formState.errors, name, error)\r\n                : unset(_formState.errors, name);\r\n        }\r\n        if ((isWatched ||\r\n            (error ? !deepEqual(previousError, error) : previousError) ||\r\n            !isEmptyObject(fieldState) ||\r\n            _formState.isValid !== isValid) &&\r\n            !shouldSkipRender) {\r\n            const updatedFormState = Object.assign(Object.assign(Object.assign({}, fieldState), (_proxyFormState.isValid && formOptions.resolver ? { isValid } : {})), { errors: _formState.errors, name });\r\n            _formState = Object.assign(Object.assign({}, _formState), updatedFormState);\r\n            _subjects.state.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        _validateCount[name]--;\r\n        if (!_validateCount[name]) {\r\n            _subjects.state.next({\r\n                isValidating: false,\r\n            });\r\n            _validateCount = {};\r\n        }\r\n    };\r\n    const setFieldValue = (name, value, options = {}, shouldRender) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                set(_formValues, name, getFieldValueAs(value, _f));\r\n                const fieldValue = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(value)\r\n                    ? ''\r\n                    : value;\r\n                if (isFileInput(_f.ref) && !isString(fieldValue)) {\r\n                    _f.ref.files = fieldValue;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = fieldValue.includes(selectRef.value)));\r\n                }\r\n                else if (_f.refs) {\r\n                    if (isCheckBoxInput(_f.ref)) {\r\n                        _f.refs.length > 1\r\n                            ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(fieldValue)\r\n                                ? !!fieldValue.find((data) => data === checkboxRef.value)\r\n                                : fieldValue === checkboxRef.value))\r\n                            : (_f.refs[0].checked = !!fieldValue);\r\n                    }\r\n                    else {\r\n                        _f.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));\r\n                    }\r\n                }\r\n                else {\r\n                    _f.ref.value = fieldValue;\r\n                }\r\n                if (shouldRender) {\r\n                    _subjects.control.next({\r\n                        values: getValues(),\r\n                        name,\r\n                    });\r\n                }\r\n                (options.shouldDirty || options.shouldTouch) &&\r\n                    updateTouchAndDirtyState(name, fieldValue, options.shouldTouch);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n        }\r\n    };\r\n    const updateTouchAndDirtyState = (name, inputValue, isCurrentTouched, shouldRender = true) => {\r\n        const state = {\r\n            name,\r\n        };\r\n        let isChanged = false;\r\n        if (_proxyFormState.isDirty) {\r\n            const previousIsDirty = _formState.isDirty;\r\n            _formState.isDirty = _getIsDirty();\r\n            state.isDirty = _formState.isDirty;\r\n            isChanged = previousIsDirty !== state.isDirty;\r\n        }\r\n        if (_proxyFormState.dirtyFields && !isCurrentTouched) {\r\n            const isPreviousFieldDirty = get(_formState.dirtyFields, name);\r\n            const isCurrentFieldDirty = !deepEqual(get(_defaultValues, name), inputValue);\r\n            isCurrentFieldDirty\r\n                ? set(_formState.dirtyFields, name, true)\r\n                : unset(_formState.dirtyFields, name);\r\n            state.dirtyFields = _formState.dirtyFields;\r\n            isChanged =\r\n                isChanged || isPreviousFieldDirty !== get(_formState.dirtyFields, name);\r\n        }\r\n        const isPreviousFieldTouched = get(_formState.touchedFields, name);\r\n        if (isCurrentTouched && !isPreviousFieldTouched) {\r\n            set(_formState.touchedFields, name, isCurrentTouched);\r\n            state.touchedFields = _formState.touchedFields;\r\n            isChanged =\r\n                isChanged ||\r\n                    (_proxyFormState.touchedFields &&\r\n                        isPreviousFieldTouched !== isCurrentTouched);\r\n        }\r\n        isChanged && shouldRender && _subjects.state.next(state);\r\n        return isChanged ? state : {};\r\n    };\r\n    const executeResolver = async (name) => {\r\n        return formOptions.resolver\r\n            ? await formOptions.resolver(Object.assign({}, _formValues), formOptions.context, getResolverOptions(name || _names.mount, _fields, formOptions.criteriaMode, formOptions.shouldUseNativeValidation))\r\n            : {};\r\n    };\r\n    const executeResolverValidation = async (names) => {\r\n        const { errors } = await executeResolver();\r\n        if (names) {\r\n            for (const name of names) {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(_formState.errors, name, error)\r\n                    : unset(_formState.errors, name);\r\n            }\r\n        }\r\n        else {\r\n            _formState.errors = errors;\r\n        }\r\n        return errors;\r\n    };\r\n    const validateForm = async (_fields, shouldCheckValid, context = {\r\n        valid: true,\r\n    }) => {\r\n        for (const name in _fields) {\r\n            const field = _fields[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const val = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, get(_formValues, _f.name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation);\r\n                    if (shouldCheckValid) {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (fieldError[_f.name]) {\r\n                            context.valid = false;\r\n                        }\r\n                        fieldError[_f.name]\r\n                            ? set(_formState.errors, _f.name, fieldError[_f.name])\r\n                            : unset(_formState.errors, _f.name);\r\n                    }\r\n                }\r\n                val && (await validateForm(val, shouldCheckValid, context));\r\n            }\r\n        }\r\n        return context.valid;\r\n    };\r\n    const handleChange = async ({ type, target, target: { value, name, type: inputType }, }) => {\r\n        let error;\r\n        let isValid;\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange } = getValidationModes(formOptions.reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !formOptions.resolver &&\r\n                !get(_formState.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(_formState.touchedFields, name), isSubmitted: _formState.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                set(_formValues, name, inputValue);\r\n            }\r\n            const fieldState = updateTouchAndDirtyState(name, inputValue, isBlurEvent, false);\r\n            const shouldRender = !isEmptyObject(fieldState) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    _subjects.watch.next({\r\n                        name,\r\n                        type,\r\n                    });\r\n                return (shouldRender &&\r\n                    _subjects.state.next(isWatched ? { name } : Object.assign(Object.assign({}, fieldState), { name })));\r\n            }\r\n            _validateCount[name] = _validateCount[name] ? +1 : 1;\r\n            _subjects.state.next({\r\n                isValidating: true,\r\n            });\r\n            if (formOptions.resolver) {\r\n                const { errors } = await executeResolver([name]);\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const valError = get(errors, parentNodeName, {});\r\n                    valError.type && valError.message && (error = valError);\r\n                    if (valError || get(_formState.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n            }\r\n            else {\r\n                error = (await validateField(field, get(_formValues, name), isValidateAllFieldCriteria, formOptions.shouldUseNativeValidation))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                _subjects.watch.next({\r\n                    name,\r\n                    type,\r\n                    values: getValues(),\r\n                });\r\n            shouldRenderBaseOnError(false, name, error, fieldState, isValid, isWatched);\r\n        }\r\n    };\r\n    const _updateValidAndInputValue = (name, ref, shouldSkipValueAs) => {\r\n        const field = get(_fields, name);\r\n        if (field) {\r\n            const fieldValue = get(_formValues, name);\r\n            const isValueUndefined = isUndefined(fieldValue);\r\n            const defaultValue = isValueUndefined\r\n                ? get(_defaultValues, name)\r\n                : fieldValue;\r\n            if (isUndefined(defaultValue) ||\r\n                (ref && ref.defaultChecked) ||\r\n                shouldSkipValueAs) {\r\n                set(_formValues, name, shouldSkipValueAs ? defaultValue : getFieldValue(field));\r\n            }\r\n            else {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        _isMounted && _proxyFormState.isValid && _updateValid();\r\n    };\r\n    const _getIsDirty = (name, data) => {\r\n        name && data && set(_formValues, name, data);\r\n        return !deepEqual(Object.assign({}, getValues()), _defaultValues);\r\n    };\r\n    const _updateValid = async () => {\r\n        const isValid = formOptions.resolver\r\n            ? isEmptyObject((await executeResolver()).errors)\r\n            : await validateForm(_fields, true);\r\n        if (isValid !== _formState.isValid) {\r\n            _formState.isValid = isValid;\r\n            _subjects.state.next({\r\n                isValid,\r\n            });\r\n        }\r\n    };\r\n    const setValues = (name, value, options) => Object.entries(value).forEach(([fieldKey, fieldValue]) => {\r\n        const fieldName = `${name}.${fieldKey}`;\r\n        const field = get(_fields, fieldName);\r\n        const isFieldArray = _names.array.has(name);\r\n        (isFieldArray || !isPrimitive(fieldValue) || (field && !field._f)) &&\r\n            !isDateObject(fieldValue)\r\n            ? setValues(fieldName, fieldValue, options)\r\n            : setFieldValue(fieldName, fieldValue, options, true);\r\n    });\r\n    const _getWatch = (fieldNames, defaultValue, isGlobal) => {\r\n        const fieldValues = Object.assign({}, (_isMounted\r\n            ? _formValues\r\n            : isUndefined(defaultValue)\r\n                ? _defaultValues\r\n                : isString(fieldNames)\r\n                    ? { [fieldNames]: defaultValue }\r\n                    : defaultValue));\r\n        if (!fieldNames) {\r\n            isGlobal && (_names.watchAll = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && _names.watch.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return Array.isArray(fieldNames)\r\n            ? result\r\n            : isObject(result[0])\r\n                ? Object.assign({}, result[0]) : Array.isArray(result[0])\r\n                ? [...result[0]]\r\n                : result[0];\r\n    };\r\n    const _updateValues = (defaultValues, name = '') => {\r\n        for (const key in defaultValues) {\r\n            const value = defaultValues[key];\r\n            const fieldName = name + (name ? '.' : '') + key;\r\n            const field = get(_fields, fieldName);\r\n            if (!field || !field._f) {\r\n                if (isObject(value) || Array.isArray(value)) {\r\n                    _updateValues(value, fieldName);\r\n                }\r\n                else if (!field) {\r\n                    set(_formValues, fieldName, value);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const _updateFieldArray = (keyName, name, method, args, updatedFieldArrayValuesWithKey = [], shouldSet = true, shouldSetFields = true) => {\r\n        let output;\r\n        const updatedFieldArrayValues = omitKey(updatedFieldArrayValuesWithKey, keyName);\r\n        _isInAction = true;\r\n        if (shouldSetFields && get(_fields, name)) {\r\n            output = method(get(_fields, name), args.argA, args.argB);\r\n            shouldSet && set(_fields, name, output);\r\n        }\r\n        output = method(get(_formValues, name), args.argA, args.argB);\r\n        shouldSet && set(_formValues, name, output);\r\n        if (Array.isArray(get(_formState.errors, name))) {\r\n            const output = method(get(_formState.errors, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.errors, name, output);\r\n            unsetEmptyArray(_formState.errors, name);\r\n        }\r\n        if (_proxyFormState.touchedFields && get(_formState.touchedFields, name)) {\r\n            const output = method(get(_formState.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(_formState.touchedFields, name, output);\r\n            unsetEmptyArray(_formState.touchedFields, name);\r\n        }\r\n        if (_proxyFormState.dirtyFields || _proxyFormState.isDirty) {\r\n            set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            updatedFieldArrayValues &&\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues, keyName), get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n            unsetEmptyArray(_formState.dirtyFields, name);\r\n        }\r\n        _subjects.state.next({\r\n            isDirty: _getIsDirty(name, omitKey(updatedFieldArrayValues, keyName)),\r\n            dirtyFields: _formState.dirtyFields,\r\n            errors: _formState.errors,\r\n            isValid: _formState.isValid,\r\n        });\r\n    };\r\n    const _getFieldArrayValue = (name) => get(_isMounted ? _formValues : _defaultValues, name, []);\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(_fields, name);\r\n        const isFieldArray = _names.array.has(name);\r\n        set(_formValues, name, value);\r\n        if (isFieldArray) {\r\n            _subjects.array.next({\r\n                name,\r\n                values: _formValues,\r\n            });\r\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(_formState.dirtyFields, name, setFieldArrayDirtyFields(value, get(_defaultValues, name, []), get(_formState.dirtyFields, name, [])));\r\n                _subjects.state.next({\r\n                    name,\r\n                    dirtyFields: _formState.dirtyFields,\r\n                    isDirty: _getIsDirty(name, value),\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            field && !field._f && !isNullOrUndefined(value)\r\n                ? setValues(name, value, options)\r\n                : setFieldValue(name, value, options, true);\r\n        }\r\n        isFieldWatched(name) && _subjects.state.next({});\r\n        _subjects.watch.next({\r\n            name,\r\n        });\r\n    };\r\n    const trigger = async (name, options = {}) => {\r\n        const fieldNames = convertToArrayPayload(name);\r\n        let isValid;\r\n        _subjects.state.next({\r\n            isValidating: true,\r\n        });\r\n        if (formOptions.resolver) {\r\n            const schemaResult = await executeResolverValidation(isUndefined(name) ? name : fieldNames);\r\n            isValid = name\r\n                ? fieldNames.every((name) => !get(schemaResult, name))\r\n                : isEmptyObject(schemaResult);\r\n        }\r\n        else {\r\n            if (name) {\r\n                isValid = (await Promise.all(fieldNames.map(async (fieldName) => {\r\n                    const field = get(_fields, fieldName);\r\n                    return await validateForm(field._f ? { [fieldName]: field } : field);\r\n                }))).every(Boolean);\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n                isValid = isEmptyObject(_formState.errors);\r\n            }\r\n        }\r\n        _subjects.state.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: _formState.errors, isValidating: false }));\r\n        if (options.shouldFocus && !isValid) {\r\n            focusFieldBy(_fields, (key) => get(_formState.errors, key), name ? fieldNames : _names.mount);\r\n        }\r\n        _proxyFormState.isValid && _updateValid();\r\n        return isValid;\r\n    };\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, _defaultValues), _formValues);\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName))\r\n            : (_formState.errors = {});\r\n        _subjects.state.next({\r\n            errors: _formState.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;\r\n        set(_formState.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        _subjects.state.next({\r\n            name,\r\n            errors: _formState.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? _subjects.watch.subscribe({\r\n            next: (info) => fieldName(_getWatch(undefined, defaultValue), info),\r\n        })\r\n        : _getWatch(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name ? convertToArrayPayload(name) : _names.mount) {\r\n            _names.mount.delete(inputName);\r\n            _names.array.delete(inputName);\r\n            if (get(_fields, inputName)) {\r\n                if (!options.keepValue) {\r\n                    unset(_fields, inputName);\r\n                    unset(_formValues, inputName);\r\n                }\r\n                !options.keepError && unset(_formState.errors, inputName);\r\n                !options.keepDirty && unset(_formState.dirtyFields, inputName);\r\n                !options.keepTouched && unset(_formState.touchedFields, inputName);\r\n                !formOptions.shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(_defaultValues, inputName);\r\n            }\r\n        }\r\n        _subjects.watch.next({});\r\n        _subjects.state.next(Object.assign(Object.assign({}, _formState), (!options.keepDirty ? {} : { isDirty: _getIsDirty() })));\r\n        !options.keepIsValid && _updateValid();\r\n    };\r\n    const registerFieldRef = (name, fieldRef, options) => {\r\n        register(name, options);\r\n        let field = get(_fields, name);\r\n        const ref = isUndefined(fieldRef.value)\r\n            ? fieldRef.querySelectorAll\r\n                ? fieldRef.querySelectorAll('input,select,textarea')[0] ||\r\n                    fieldRef\r\n                : fieldRef\r\n            : fieldRef;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isRadioOrCheckbox &&\r\n                compact(field._f.refs || []).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(_fields, name, field);\r\n        _updateValidAndInputValue(name, ref);\r\n    };\r\n    const register = (name, options = {}) => {\r\n        const field = get(_fields, name);\r\n        set(_fields, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        if (options.value) {\r\n            set(_formValues, name, options.value);\r\n        }\r\n        if (!isUndefined(options.disabled) &&\r\n            field &&\r\n            field._f &&\r\n            field._f.ref.disabled !== options.disabled) {\r\n            set(_formValues, name, options.disabled ? undefined : field._f.ref.value);\r\n        }\r\n        _names.mount.add(name);\r\n        !field && _updateValidAndInputValue(name, undefined, true);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : Object.assign(Object.assign({ name }, (isUndefined(options.disabled)\r\n                ? {}\r\n                : { disabled: options.disabled })), { onChange: handleChange, onBlur: handleChange, ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(_fields, name, {});\r\n                        const _shouldUnregister = formOptions.shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                        }\r\n                        _shouldUnregister &&\r\n                            !(isNameInFieldArray(_names.array, name) && _isInAction) &&\r\n                            _names.unMount.add(name);\r\n                    }\r\n                } });\r\n    };\r\n    const handleSubmit = (onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = Object.assign({}, _formValues);\r\n        _subjects.state.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (formOptions.resolver) {\r\n                const { errors, values } = await executeResolver();\r\n                _formState.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(_fields);\r\n            }\r\n            if (isEmptyObject(_formState.errors) &&\r\n                Object.keys(_formState.errors).every((name) => get(fieldValues, name))) {\r\n                _subjects.state.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(_formState.errors, e));\r\n                formOptions.shouldFocusError &&\r\n                    focusFieldBy(_fields, (key) => get(_formState.errors, key), _names.mount);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            _formState.isSubmitted = true;\r\n            _subjects.state.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && hasNoPromiseError,\r\n                submitCount: _formState.submitCount + 1,\r\n                errors: _formState.errors,\r\n            });\r\n        }\r\n    };\r\n    const reset = (formValues, keepStateOptions = {}) => {\r\n        const updatedValues = formValues || _defaultValues;\r\n        const values = cloneObject(updatedValues);\r\n        _formValues = values;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of _names.mount) {\r\n                const field = get(_fields, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        if (!keepStateOptions.keepDefaultValues) {\r\n            _defaultValues = Object.assign({}, updatedValues);\r\n        }\r\n        if (!keepStateOptions.keepValues) {\r\n            _fields = {};\r\n            _subjects.control.next({\r\n                values: keepStateOptions.keepDefaultValues\r\n                    ? _defaultValues\r\n                    : Object.assign({}, updatedValues),\r\n            });\r\n            _subjects.watch.next({});\r\n            _subjects.array.next({\r\n                values,\r\n            });\r\n        }\r\n        _names = {\r\n            mount: new Set(),\r\n            unMount: new Set(),\r\n            array: new Set(),\r\n            watch: new Set(),\r\n            watchAll: false,\r\n            focus: '',\r\n        };\r\n        _subjects.state.next({\r\n            submitCount: keepStateOptions.keepSubmitCount\r\n                ? _formState.submitCount\r\n                : 0,\r\n            isDirty: keepStateOptions.keepDirty\r\n                ? _formState.isDirty\r\n                : keepStateOptions.keepDefaultValues\r\n                    ? deepEqual(formValues, _defaultValues)\r\n                    : false,\r\n            isSubmitted: keepStateOptions.keepIsSubmitted\r\n                ? _formState.isSubmitted\r\n                : false,\r\n            dirtyFields: keepStateOptions.keepDirty ? _formState.dirtyFields : {},\r\n            touchedFields: keepStateOptions.keepTouched\r\n                ? _formState.touchedFields\r\n                : {},\r\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n        _isMounted = !!keepStateOptions.keepIsValid;\r\n    };\r\n    const setFocus = (name) => get(_fields, name)._f.ref.focus();\r\n    const _removeFields = () => {\r\n        for (const name of _names.unMount) {\r\n            const field = get(_fields, name);\r\n            field &&\r\n                (field._f.refs ? field._f.refs.every(live) : live(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        _names.unMount = new Set();\r\n    };\r\n    return {\r\n        control: {\r\n            register,\r\n            unregister,\r\n            _getWatch,\r\n            _getIsDirty,\r\n            _updateValid,\r\n            _updateValues,\r\n            _removeFields,\r\n            _updateFieldArray,\r\n            _getFieldArrayValue,\r\n            _subjects,\r\n            _shouldUnregister: formOptions.shouldUnregister,\r\n            _fields,\r\n            _proxyFormState,\r\n            get _formValues() {\r\n                return _formValues;\r\n            },\r\n            set _formValues(value) {\r\n                _formValues = value;\r\n            },\r\n            get _isMounted() {\r\n                return _isMounted;\r\n            },\r\n            set _isMounted(value) {\r\n                _isMounted = value;\r\n            },\r\n            get _defaultValues() {\r\n                return _defaultValues;\r\n            },\r\n            set _defaultValues(value) {\r\n                _defaultValues = value;\r\n            },\r\n            get _names() {\r\n                return _names;\r\n            },\r\n            set _names(value) {\r\n                _names = value;\r\n            },\r\n            _isInAction: {\r\n                get val() {\r\n                    return _isInAction;\r\n                },\r\n                set val(value) {\r\n                    _isInAction = value;\r\n                },\r\n            },\r\n            _formState: {\r\n                get val() {\r\n                    return _formState;\r\n                },\r\n                set val(value) {\r\n                    _formState = value;\r\n                },\r\n            },\r\n            _updateProps: (options) => {\r\n                formOptions = Object.assign(Object.assign({}, defaultOptions), options);\r\n            },\r\n        },\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch,\r\n        setValue,\r\n        getValues,\r\n        reset,\r\n        clearErrors,\r\n        unregister,\r\n        setError,\r\n        setFocus,\r\n    };\r\n}\n\nfunction useForm(props = {}) {\r\n    const _formControl = React.useRef();\r\n    const [formState, updateFormState] = React.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: false,\r\n        errors: {},\r\n    });\r\n    if (_formControl.current) {\r\n        _formControl.current.control._updateProps(props);\r\n    }\r\n    else {\r\n        _formControl.current = Object.assign(Object.assign({}, createFormControl(props)), { formState });\r\n    }\r\n    const control = _formControl.current.control;\r\n    React.useEffect(() => {\r\n        const formStateSubscription = control._subjects.state.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, control._proxyFormState, true)) {\r\n                    control._formState.val = Object.assign(Object.assign({}, control._formState.val), formState);\r\n                    updateFormState(Object.assign({}, control._formState.val));\r\n                }\r\n            },\r\n        });\r\n        return () => {\r\n            formStateSubscription.unsubscribe();\r\n        };\r\n    }, [control]);\r\n    React.useEffect(() => {\r\n        if (!control._isMounted) {\r\n            control._isMounted = true;\r\n            control._proxyFormState.isValid && control._updateValid();\r\n            !props.shouldUnregister && control._updateValues(control._defaultValues);\r\n        }\r\n        control._removeFields();\r\n    });\r\n    _formControl.current.formState = getProxyFormState(formState, control._proxyFormState);\r\n    return _formControl.current;\r\n}\n\nfunction useWatch(props) {\r\n    const methods = useFormContext();\r\n    const { control = methods.control, name, defaultValue, disabled, } = props || {};\r\n    const _name = React.useRef(name);\r\n    _name.current = name;\r\n    const [value, updateValue] = React.useState(isUndefined(defaultValue)\r\n        ? control._getWatch(name)\r\n        : defaultValue);\r\n    React.useEffect(() => {\r\n        const watchSubscription = control._subjects.watch.subscribe({\r\n            next: ({ name }) => {\r\n                (!_name.current ||\r\n                    !name ||\r\n                    convertToArrayPayload(_name.current).some((fieldName) => name &&\r\n                        fieldName &&\r\n                        (fieldName.startsWith(name) ||\r\n                            name.startsWith(fieldName)))) &&\r\n                    updateValue(control._getWatch(_name.current, defaultValue));\r\n            },\r\n        });\r\n        disabled && watchSubscription.unsubscribe();\r\n        return () => watchSubscription.unsubscribe();\r\n    }, [disabled, control, defaultValue]);\r\n    React.useEffect(() => {\r\n        control._removeFields();\r\n    });\r\n    return value;\r\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };\n//# sourceMappingURL=index.esm.js.map\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}"]}}